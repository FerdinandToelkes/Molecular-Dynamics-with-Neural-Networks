import argparse
import yaml
import os
import matplotlib.pyplot as plt
import time

from torch.utils.data import DataLoader

from md_with_schnet.setup_logger import setup_logger
from md_with_schnet.utils import set_plotting_config, load_xtb_dataset, set_data_prefix
from md_with_schnet.data_analysis.MD17_vs_rMD17.molecule_analyzer import MoleculeTrajectoryAnalyzer

logger = setup_logger(logging_level_str="debug")

# Script to generate plots comparing different properties of an XTB dataset.
# Example command to run the script from within code directory:
"""
python -m md_with_schnet.data_analysis.XTB.main --trajectory_dir MOTOR_MD_XTB/T300_1 --show_plots
"""


def parse_args() -> dict:
    """ 
    Parse command-line arguments. 
    Returns:
        dict: Dictionary containing command-line arguments.
    """
    parser = argparse.ArgumentParser(description="Plotting script for XTB datasets")
    parser.add_argument("--trajectory_dir", type=str, default="MOTOR_MD_XTB/T300_1", help="Directory containing the trajectory data generated by Turbomole (default: MOTOR_MD_XTB/T300_1)")
    parser.add_argument("--show_plots", action="store_true", help="Show plots before saving them (default: False)")
    return vars(parser.parse_args())


def combine_plots(plot_dir: str, plot_type: str, comparer_function: callable, extra_args: dict = {}, show_plots: bool = False):
    """ General function to create subplot grids and call comparison functions. 
    
    Args:
        plot_dir (str): Directory to save the plot to.
        plot_type (str): Type of plot to create.
        comparer_function (function): Function to compare values.
        extra_args (dict, optional): Additional arguments for the comparer function. Defaults to {}.
    """
    sharey = "autocorrelation" in plot_type or "distributions" in plot_type
    fig, axes = plt.subplots(3)  
    
    for i, key in enumerate(["energies", "total_forces", "displacements"]):
        comparer_function(key, ax=axes[i], **extra_args.get(key, {}))

    plt.tight_layout()
    path = os.path.join(plot_dir, f"{plot_type}.pdf")
    plt.savefig(path, dpi=300, bbox_inches='tight')
    logger.info(f"Saved plot to: {path}")
    if show_plots:
        plt.show()
    plt.close()

def main(trajectory_dir: str, show_plots: bool):
    # setup
    work_dir = os.path.expanduser('~/whk/code/md_with_schnet/data_analysis/XTB')
    plot_dir = os.path.expanduser('~/whk/code/md_with_schnet/data_analysis/plots')
    data_prefix = os.path.join(set_data_prefix(), trajectory_dir)
    target_path = os.path.join(data_prefix, 'md_trajectory.db')

    # load XTB dataset
    xtb = load_xtb_dataset(target_path)
 
    # setup plotting use textwidth and height to set aspect ratio
    # Text width: 468.0pt, Text height: 665.5pt
    set_plotting_config(fontsize=10, aspect_ratio=468/525, width_fraction=1)
 
    # Load the YAML configuration
    with open(os.path.join(work_dir, "plot_configs.yaml"), "r") as file:
        plot_config = yaml.safe_load(file)

    for nr_configs_as_str in plot_config.keys():
        start = time.time()
        n_samples = int(nr_configs_as_str.split("_")[0])
        c = plot_config[nr_configs_as_str]
        logger.info(f"Plotting for n_samples: {n_samples}")

        path_to_plot_dir = os.path.join(plot_dir, f"XTB/{nr_configs_as_str}")
        os.makedirs(path_to_plot_dir, exist_ok=True)

        batch_size = 1000 if n_samples > 1000 else n_samples

        loader = DataLoader(
            dataset=xtb.dataset,
            batch_size=batch_size,
            shuffle=False,
            num_workers=0,   # or more depending on your CPU
            pin_memory=False
        )

        # Initialize the trajectory analyzer
        desired_batches = n_samples // batch_size
        analyzer = MoleculeTrajectoryAnalyzer(loader, "XTB", desired_batches, path_to_plot_dir)
        
        if c["plot_distributions"]:
            combine_plots(
                path_to_plot_dir,
                "distributions",
                analyzer.plot_distribution,
                extra_args={
                    "energies": {"xlabel": "Energy (Hartree)", "set_title": True}, 
                    "total_forces": {"xlabel": r"Force Magnitude ($\mathrm{Hartree}/\mathrm{Bohr}$)"},
                    "displacements": {"xlabel": r"Displacement ($\mathrm{\AA}$)", "legend_location": "upper right"}
                    },
                show_plots=show_plots
            )

        if c["plot_values"]:
            combine_plots(
                path_to_plot_dir,
                "values",
                analyzer.plot_values,
                extra_args={
                    "energies": {"ylabel": "Energy (Hartree)", "set_title": True}, 
                    "total_forces": {"ylabel": r"Force Magnitude ($\mathrm{Hartree}/\mathrm{Bohr}$)"},
                    "displacements": {"ylabel": r"Displacement ($\mathrm{\AA}$)","set_xlabel": True}
                    },
                show_plots=show_plots
            )

        if c["plot_values_connected"]:
            combine_plots(
                path_to_plot_dir,
                "values_connected",
                analyzer.plot_values_connected,
                extra_args={
                    "energies": {"ylabel": "Energy (Hartree)", "set_title": True}, 
                    "total_forces": {"ylabel": r"Force Magnitude ($\mathrm{Hartree}/\mathrm{Bohr}$)"},
                    "displacements": {"ylabel": r"Displacement ($\mathrm{\AA}$)", "set_xlabel": True}
                    },
                show_plots=show_plots
            )

        if c["plot_autocorrelation"]:
            lags = c["autocorrelation_lags"]
            combine_plots(
                path_to_plot_dir,
                "autocorrelation",
                analyzer.plot_autocorrelation,
                extra_args={
                    "energies": {"set_title": True, "lags": lags},
                    "total_forces": {"lags": lags},
                    "displacements": {"set_xlabel": True, "lags": lags},
                    },
                show_plots=show_plots
            )
        logger.info(f"Time taken for {n_samples} samples: {time.time() - start:.2f} seconds")


if __name__=="__main__":
    args = parse_args()
    main(**args)