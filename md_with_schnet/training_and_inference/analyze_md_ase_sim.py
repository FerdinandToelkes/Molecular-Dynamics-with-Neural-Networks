import os
import argparse
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

from hydra import initialize, compose
from omegaconf import OmegaConf, DictConfig
from schnetpack import properties
from schnetpack import units as spk_units
from schnetpack.md.data import HDF5Loader, PowerSpectrum
from ase.io import write, read


from md_with_schnet.utils import set_data_prefix, set_plotting_config, load_xtb_dataset
from md_with_schnet.setup_logger import setup_logger
from md_with_schnet.neural_net.inference_with_ase import update_config_with_train_config

# for interactive plotting
import plotly.graph_objects as go

logger = setup_logger("debug")

# Example command to run the script from within code directory:
"""
python -m md_with_schnet.neural_net.analyze_md_ase_sim --model_dir MOTOR_MD_XTB_T300_1_epochs_1000_bs_100_lr_0.0001_seed_42 --simulation_name  md_sim_steps_5000_time_step_1.0_seed_42 --n_samples 200
"""

def parse_args() -> dict:
    """ 
    Parse command-line arguments. 
    Returns:
        dict: Dictionary containing command-line arguments.
    """
    parser = argparse.ArgumentParser(description="Script for analyzing the trajectory predicted with the trained model on XTB test data.")
    # paths setup
    parser.add_argument("--trajectory_dir", type=str, default="MOTOR_MD_XTB/T300_1", help="Directory containing the trajectory data generated by Turbomole (default: MOTOR_MD_XTB/T300_1)")
    parser.add_argument("-mdir", "--model_dir", type=str, default="MOTOR_MD_XTB_T300_1_epochs_1000_bs_100_lr_0.0001_seed_42", help="Directory of the trained model (default: MOTOR_MD_XTB_T300_1_epochs_1000_bs_100_lr_0.0001_seed_42)")
    parser.add_argument("-sn", "--simulation_name", type=str, default="md_sim_steps_10000_time_step_0.5_seed_42", help="Name of the MD simulation (default: md_sim_steps_2000_time_step_0.5_seed_42)")
    # analysis setup
    parser.add_argument("-ns", "--n_samples", type=int, default=100, help="Number of samples to analyze (default: 1000)")
    parser.add_argument("-fs", "--first_sample", type=int, default=0, help="First sample to analyze (default: 0)")
    return vars(parser.parse_args())

def plot_energies_system_vs_calculator(data: HDF5Loader, energies_system: np.ndarray, energies_calculator: np.ndarray):
    """ Plot the energies of the system and the calculator.
    Args:
        data (HDF5Loader): HDF5Loader object containing the MD simulation data.
        energies_system (np.ndarray): Energies of the system.
        energies_calculator (np.ndarray): Energies of the calculator.
    """
    # Get the time axis in femtoseconds
    time_axis = np.arange(data.entries) * data.time_step / spk_units.fs 

    set_plotting_config()
    plt.figure()
    plt.plot(time_axis, energies_system, label=r"E$_\mathrm{pot}$ (System)")
    plt.plot(time_axis, energies_calculator, label=r"E$_\mathrm{pot}$ (Logger)", ls="--")
    plt.ylabel("E [Hartree]")
    plt.xlabel("t [fs]")
    plt.xlim(9800,10000)
    plt.legend()
    plt.tight_layout()
    plt.show()

def plot_energies(data: HDF5Loader, true_energies: np.ndarray, predicted_energies: np.ndarray):
    """ Plot the energies of the system and the calculator.
    Args:
        data (HDF5Loader): HDF5Loader object containing the MD simulation data.
        true_energies (np.ndarray): Energies of the calculator.
        predicted_energies (np.ndarray): Energies of the system.
    """
    # Get the time axis in femtoseconds
    time_axis = np.arange(data.entries) * data.time_step / spk_units.fs 
    time_axis = time_axis[:len(true_energies)]
    predicted_energies = predicted_energies[:len(true_energies)]

    set_plotting_config()
    plt.figure()
    
    # Plot true energies
    ax1 = plt.gca()
    line1, = ax1.plot(time_axis, true_energies, label=r"True $E_\mathrm{pot}$", color='tab:orange')
    ax1.set_ylabel("E [Hartree]", color='tab:orange')
    ax1.tick_params(axis='y', labelcolor='tab:orange')

    # Plot predicted energies on the twin axis
    ax2 = ax1.twinx()
    line2, = ax2.plot(time_axis, predicted_energies, label=r"Predicted $E_\mathrm{pot}$", color='tab:blue')
    ax2.set_ylabel("E [Hartree]", color='tab:blue')
    ax2.tick_params(axis='y', labelcolor='tab:blue')

    ax1.set_xlabel("Time [fs]")

    # Create a combined legend
    lines = [line1, line2]
    labels = [line.get_label() for line in lines]
    ax1.legend(lines, labels, loc='upper right')

    #plt.legend()
    plt.tight_layout()
    plt.show()

def plot_temperature(data: HDF5Loader):
    """ Plot the temperature of the system.
    Args:
        data (HDF5Loader): HDF5Loader object containing the MD simulation data.
    """
    set_plotting_config()

    # Read the temperature
    temperature = data.get_temperature()

    # Compute the cumulative mean
    temperature_mean = np.cumsum(temperature) / (np.arange(data.entries)+1)

    # Get the time axis
    time_axis = np.arange(data.entries) * data.time_step / spk_units.fs  # in fs

    plt.figure(figsize=(8,4))
    plt.plot(time_axis, temperature, label='T')
    plt.plot(time_axis, temperature_mean, label='T (avg.)')
    plt.ylabel('T [K]')
    plt.xlabel('t [fs]')
    plt.legend()
    plt.tight_layout()
    plt.show()

def plot_spectrum(frequencies: np.ndarray, intensities: np.ndarray):
    """ Plot the spectrum.
    Args:
        frequencies (np.ndarray): Frequencies of the spectrum.
        intensities (np.ndarray): Intensities of the spectrum.
    """
    set_plotting_config()
    # Plot the spectrum
    plt.figure()
    plt.plot(frequencies, intensities)
    plt.xlim(0,4000)
    plt.ylim(0,100)
    plt.ylabel('I [a.u.]')
    plt.xlabel(r'$\omega$ [cm$^{-1}$]')
    plt.show()


def get_data_dict(xtb_data: np.ndarray, nn_data: np.ndarray) -> dict:
    """
    Extract data from XTB and NN log files.
    Args:
        xtb_data (np.ndarray): Numpy array containing XTB data.
        nn_data (np.ndarray): Numpy array containing NN data.
    Returns:
        dict: Dictionary containing time steps and energy values for both XTB and NN.
    """
    # ase saves the time in ps
    time_steps = xtb_data[:, 0] 
    if not np.array_equal(time_steps, nn_data[:, 0]):
        raise ValueError("Time steps in XTB and NN data do not match.")
    
    xtb_e_tot = xtb_data[:, 1]  
    xtb_e_pot = xtb_data[:, 2]  
    xtb_e_kin = xtb_data[:, 3]  
    xtb_temp = xtb_data[:, 4]  
    
    nn_e_tot = nn_data[:, 1]  
    nn_e_pot = nn_data[:, 2]  
    nn_e_kin = nn_data[:, 3]  
    nn_temp = nn_data[:, 4]  

    log_data = {
        "XTB": {
            "time_steps": time_steps,
            "e_tot": xtb_e_tot,
            "e_pot": xtb_e_pot,
            "e_kin": xtb_e_kin,
            "temp": xtb_temp
        },
        "NN": {
            "time_steps": time_steps,
            "e_tot": nn_e_tot,
            "e_pot": nn_e_pot,
            "e_kin": nn_e_kin,
            "temp": nn_temp
        }
    }
    return log_data


def main(trajectory_dir: str, model_dir: str, simulation_name: str, n_samples: int, first_sample: int):
    ####################### 1) Compose the config ###########################
    with initialize(config_path="conf", job_name="inference", version_base="1.1"):
        cfg: DictConfig = compose(config_name="inference_config")

    # use training config to update the inference config
    train_cfg_path = os.path.join("runs", model_dir, "tensorboard/default/version_0")
    with initialize(config_path=train_cfg_path, job_name="train", version_base="1.1"):
        cfg_train: DictConfig = compose(config_name="hparams.yaml")
    cfg = update_config_with_train_config(cfg, cfg_train)

    ####################### 2) Prepare Data and Paths #########################
    home_dir = os.path.expanduser("~")
    md_workdir = os.path.join(home_dir, "whk/code/md_with_schnet/neural_net/runs", model_dir)
    print(f"md_workdir: {md_workdir}")
    print(f"simulation_name: {simulation_name}")
    target_dir = os.path.join(md_workdir, simulation_name)
    
    # read in the saved .traj files and save them as .xyz files
    xtb_traj = read(f'{target_dir}/xtb_traj.traj', index=':')
    nn_traj = read(f'{target_dir}/nn_traj.traj', index=':')
    write(f'{target_dir}/xtb_traj.xyz', xtb_traj)
    write(f'{target_dir}/nn_traj.xyz', nn_traj)

    # load the log file containing the MD simulation data
    xtb_data = np.loadtxt(f'{target_dir}/xtb_md.log', skiprows=1) 
    nn_data = np.loadtxt(f'{target_dir}/nn_md.log', skiprows=1) # time[ps], Etot, Epot, Ekin[eV], T[K]
    logger.debug(f"Shape of xtb_data: {xtb_data.shape}")
    logger.debug(f"Shape of nn_data: {nn_data.shape}")

    # take first n entries for plotting
    if n_samples + first_sample > xtb_data.shape[0]:
        raise ValueError(f"Requested n_samples ({n_samples}) + first_sample ({first_sample}) exceeds available data length ({xtb_data.shape[0]}).")
    xtb_data = xtb_data[first_sample:first_sample + n_samples, :]  # time[ps], Etot, Epot, Ekin[eV], T[K]
    nn_data = nn_data[first_sample:first_sample + n_samples, :]  # time[ps], Etot, Epot, Ekin[eV], T[K]

    log_data = get_data_dict(xtb_data, nn_data)
    logger.debug(f"Log data keys: {log_data.keys()}")

    
    exit()
    
    ####################### 2) Prepare Data and Paths #########################
    data_prefix = set_data_prefix()
    model_path = cfg.globals.model_path
    md_workdir = cfg.run.path

    split_file = os.path.join(data_prefix, "splits", trajectory_dir, "inner_splits_0.npz")
    if not os.path.exists(split_file):
        raise FileNotFoundError(f"Missing split file: {split_file}")
    path_to_db = os.path.join(data_prefix, trajectory_dir, "md_trajectory.db")
    logger.debug(f"Path to database: {path_to_db}")

    datamodule = load_xtb_dataset(
        db_path=path_to_db,
        num_workers=cfg.data.num_workers,
        batch_size=cfg.data.batch_size,
        split_file=split_file
    )
    # Plot energies of the actual testdata
    test_data = datamodule.test_dataset
    test_energies = []
    for i, d in enumerate(test_data):
        if i >= 200:
            break
        test_energies.append(d["energy"])
    test_energies = np.array(test_energies)
    plot_energies(data, test_energies, energies_system)
    exit()

    

    # extract structure information from HDF5 data
    trajectory_path = os.path.join(md_workdir, "trajectory.xyz")
    if not os.path.exists(trajectory_path):
        md_atoms = data.convert_to_atoms()

        # write list of Atoms to XYZ file
        write(
            trajectory_path,
            md_atoms,
            format="xyz"
        )

    # Initialize the spectrum
    equilibrated_data = HDF5Loader(log_file, skip_initial=10000) # i.e. skip first half
    spectrum = PowerSpectrum(equilibrated_data, resolution=2048)

    # Compute the spectrum for the first molecule (default)
    spectrum.compute_spectrum(molecule_idx=0)

    # Get frequencies and intensities
    frequencies, intensities = spectrum.get_spectrum()

    plot_spectrum(frequencies, intensities)

    



if __name__ == "__main__":
    args = parse_args()
    main(**args)


# code for non interactive plotting
# # plot potential energies from xtb and nn
# set_plotting_config(fontsize=10, aspect_ratio=468/525, width_fraction=1)
# fig, axes = plt.subplots(3) 
# axes[0].plot(time_steps, xtb_e_tot, label='XTB Total Energy', color='green')
# axes[0].plot(time_steps, nn_e_tot, label='NN Total Energy', color='red')
# axes[0].set_xlabel('Time [ps]')
# axes[0].set_ylabel('Total Energy [eV]')
# axes[0].set_title('Total Energy Comparison')
# axes[0].legend()
# axes[1].plot(time_steps, xtb_e_pot, label='XTB Potential Energy', color='cyan')
# axes[1].plot(time_steps, nn_e_pot, label='NN Potential Energy', color='magenta')
# axes[1].set_xlabel('Time [ps]')
# axes[1].set_ylabel('Potential Energy [eV]')
# axes[1].set_title('Potential Energy Comparison')
# axes[1].legend()
# axes[2].plot(time_steps, xtb_e_kin, label='XTB Kinetic Energy', color='purple')
# axes[2].plot(time_steps, nn_e_kin, label='NN Kinetic Energy', color='brown')
# axes[2].set_xlabel('Time [ps]')
# axes[2].set_ylabel('Kinetic Energy [eV]')
# axes[2].set_title('Kinetic Energy Comparison')
# axes[2].legend()
# plt.tight_layout()
# plt.show()

# # plot potential energies on twin axes
# set_plotting_config(fontsize=10, aspect_ratio=8/4, width_fraction=1)
# fig, ax1 = plt.subplots()
# ax1.plot(time_steps, xtb_e_pot, label='XTB Potential Energy', color='green')
# ax2 = ax1.twinx()  # create a twin Axes sharing the x-axis
# ax2.plot(time_steps, nn_e_pot, label='NN Potential Energy', color='red')
# ax1.set_xlabel('Time [ps]')
# ax1.set_ylabel('XTB Potential Energy [eV]', color='green')
# ax2.set_ylabel('NN Potential Energy [eV]', color='red')
# ax1.set_title('Potential Energy Comparison')
# ax1.tick_params(axis='y', labelcolor='green')
# ax2.tick_params(axis='y', labelcolor='red')
# # Combine legends from both axes
# lines, labels = ax1.get_legend_handles_labels()
# lines2, labels2 = ax2.get_legend_handles_labels()
# ax1.legend(lines + lines2, labels + labels2, loc='upper left')
# plt.tight_layout()
# plt.show()

# # compute rolling correlation with pandas
# xtb_df = pd.DataFrame({
#     'time': time_steps,
#     'e_pot': xtb_e_pot,
#     'e_kin': xtb_e_kin,
#     'temp': xtb_temp
# })
# nn_df = pd.DataFrame({
#     'time': time_steps,
#     'e_pot': nn_e_pot,
#     'e_kin': nn_e_kin,
#     'temp': nn_temp
# })
# # compute rolling correlation with a window of 100
# window_sizes = [100, 250, 500]
# # take first four colors from the default matplotlib color cycle
# colors = plt.rcParams['axes.prop_cycle'].by_key()['color'][:len(window_sizes)]

# xtb_nn_corrs = []
# xtb_nn_time = []
# for window_size in window_sizes:
#     xtb_nn_corr = xtb_df.rolling(window=window_size).corr(nn_df)
#     xtb_nn_corr = xtb_nn_corr.dropna()
#     xtb_nn_corrs.append(xtb_nn_corr)
#     # new time steps = time steps - window_size + 1
#     xtb_nn_time.append(xtb_df['time'][:-(window_size-1)]) 
#     logger.debug(f"XTB correlation shape: {xtb_nn_corr.shape}")

# # plot the rolling correlation
# set_plotting_config(fontsize=10, aspect_ratio=8/4, width_fraction=1)
# plt.figure()
# for i, window_size in enumerate(window_sizes):
#     xtb_nn_corr = xtb_nn_corrs[i]
#     xtb_nn_time_i = xtb_nn_time[i]
#     xtb_nn_time_i = xtb_nn_time[i]
#     plt.plot(xtb_nn_time_i, xtb_nn_corr['e_pot'], label=f'Window Size {window_size}', color=colors[i])
# plt.xlabel('Time [ps]')
# plt.ylabel('Rolling Correlation')
# plt.title('Rolling Correlation between XTB and NN Potential Energies')
# plt.legend()
# plt.tight_layout()
# plt.show()
