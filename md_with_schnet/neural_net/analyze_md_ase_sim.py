import os
import argparse
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

from hydra import initialize, compose
from omegaconf import OmegaConf, DictConfig
from schnetpack import properties
from schnetpack import units as spk_units
from schnetpack.md.data import HDF5Loader, PowerSpectrum
from ase.io import write, read


from md_with_schnet.utils import set_data_prefix, set_plotting_config, load_xtb_dataset
from md_with_schnet.setup_logger import setup_logger
from md_with_schnet.neural_net.inference_with_ase import update_config_with_train_config

# for interactive plotting
import plotly.graph_objects as go

logger = setup_logger("debug")

# Example command to run the script from within code directory:
"""
python -m md_with_schnet.neural_net.analyze_md_ase_sim --model_dir MOTOR_MD_XTB_T300_1_epochs_1000_bs_100_lr_0.0001_seed_42 --simulation_name  md_sim_steps_5000_time_step_1.0_seed_42 --n_samples 200
"""

def parse_args() -> dict:
    """ 
    Parse command-line arguments. 
    Returns:
        dict: Dictionary containing command-line arguments.
    """
    parser = argparse.ArgumentParser(description="Script for analyzing the trajectory predicted with the trained model on XTB test data.")
    # paths setup
    parser.add_argument("--trajectory_dir", type=str, default="MOTOR_MD_XTB/T300_1", help="Directory containing the trajectory data generated by Turbomole (default: MOTOR_MD_XTB/T300_1)")
    parser.add_argument("-mdir", "--model_dir", type=str, default="MOTOR_MD_XTB_T300_1_epochs_1000_bs_100_lr_0.0001_seed_42", help="Directory of the trained model (default: MOTOR_MD_XTB_T300_1_epochs_1000_bs_100_lr_0.0001_seed_42)")
    parser.add_argument("-sn", "--simulation_name", type=str, default="md_sim_steps_10000_time_step_0.5_seed_42", help="Name of the MD simulation (default: md_sim_steps_2000_time_step_0.5_seed_42)")
    # analysis setup
    parser.add_argument("-ns", "--n_samples", type=int, default=100, help="Number of samples to analyze (default: 1000)")
    parser.add_argument("-fs", "--first_sample", type=int, default=0, help="First sample to analyze (default: 0)")
    return vars(parser.parse_args())

def plot_energies_system_vs_calculator(data: HDF5Loader, energies_system: np.ndarray, energies_calculator: np.ndarray):
    """ Plot the energies of the system and the calculator.
    Args:
        data (HDF5Loader): HDF5Loader object containing the MD simulation data.
        energies_system (np.ndarray): Energies of the system.
        energies_calculator (np.ndarray): Energies of the calculator.
    """
    # Get the time axis in femtoseconds
    time_axis = np.arange(data.entries) * data.time_step / spk_units.fs 

    set_plotting_config()
    plt.figure()
    plt.plot(time_axis, energies_system, label=r"E$_\mathrm{pot}$ (System)")
    plt.plot(time_axis, energies_calculator, label=r"E$_\mathrm{pot}$ (Logger)", ls="--")
    plt.ylabel("E [Hartree]")
    plt.xlabel("t [fs]")
    plt.xlim(9800,10000)
    plt.legend()
    plt.tight_layout()
    plt.show()

def plot_energies(data: HDF5Loader, true_energies: np.ndarray, predicted_energies: np.ndarray):
    """ Plot the energies of the system and the calculator.
    Args:
        data (HDF5Loader): HDF5Loader object containing the MD simulation data.
        true_energies (np.ndarray): Energies of the calculator.
        predicted_energies (np.ndarray): Energies of the system.
    """
    # Get the time axis in femtoseconds
    time_axis = np.arange(data.entries) * data.time_step / spk_units.fs 
    time_axis = time_axis[:len(true_energies)]
    predicted_energies = predicted_energies[:len(true_energies)]

    set_plotting_config()
    plt.figure()
    
    # Plot true energies
    ax1 = plt.gca()
    line1, = ax1.plot(time_axis, true_energies, label=r"True $E_\mathrm{pot}$", color='tab:orange')
    ax1.set_ylabel("E [Hartree]", color='tab:orange')
    ax1.tick_params(axis='y', labelcolor='tab:orange')

    # Plot predicted energies on the twin axis
    ax2 = ax1.twinx()
    line2, = ax2.plot(time_axis, predicted_energies, label=r"Predicted $E_\mathrm{pot}$", color='tab:blue')
    ax2.set_ylabel("E [Hartree]", color='tab:blue')
    ax2.tick_params(axis='y', labelcolor='tab:blue')

    ax1.set_xlabel("Time [fs]")

    # Create a combined legend
    lines = [line1, line2]
    labels = [line.get_label() for line in lines]
    ax1.legend(lines, labels, loc='upper right')

    #plt.legend()
    plt.tight_layout()
    plt.show()

def plot_temperature(data: HDF5Loader):
    """ Plot the temperature of the system.
    Args:
        data (HDF5Loader): HDF5Loader object containing the MD simulation data.
    """
    set_plotting_config()

    # Read the temperature
    temperature = data.get_temperature()

    # Compute the cumulative mean
    temperature_mean = np.cumsum(temperature) / (np.arange(data.entries)+1)

    # Get the time axis
    time_axis = np.arange(data.entries) * data.time_step / spk_units.fs  # in fs

    plt.figure(figsize=(8,4))
    plt.plot(time_axis, temperature, label='T')
    plt.plot(time_axis, temperature_mean, label='T (avg.)')
    plt.ylabel('T [K]')
    plt.xlabel('t [fs]')
    plt.legend()
    plt.tight_layout()
    plt.show()

def plot_spectrum(frequencies: np.ndarray, intensities: np.ndarray):
    """ Plot the spectrum.
    Args:
        frequencies (np.ndarray): Frequencies of the spectrum.
        intensities (np.ndarray): Intensities of the spectrum.
    """
    set_plotting_config()
    # Plot the spectrum
    plt.figure()
    plt.plot(frequencies, intensities)
    plt.xlim(0,4000)
    plt.ylim(0,100)
    plt.ylabel('I [a.u.]')
    plt.xlabel(r'$\omega$ [cm$^{-1}$]')
    plt.show()


def create_interactive_plot(x: np.ndarray, y1: np.ndarray, y2: np.ndarray, ylabel: str, name_1: str, name_2: str, window_size: int = 200):
    fig = go.Figure()

    # Add initial traces
    fig.add_trace(go.Scatter(x=x[:window_size], y=y1[:window_size], mode='lines', name=name_1))
    fig.add_trace(go.Scatter(x=x[:window_size], y=y2[:window_size], mode='lines', name=name_2))

    # Create steps for the slider
    steps = []
    num_windows = len(x) - window_size + 1
    for i in range(num_windows):
        step = dict(
            method="update",
            args=[{"x": [x[i:i+window_size], x[i:i+window_size]],
                "y": [y1[i:i+window_size], y2[i:i+window_size]]},
                {"title": f"Time Series Window: {i} to {i+window_size}"}],
            label=str(i)
        )
        steps.append(step)

    # Create sliders
    sliders = [dict(
        active=0,
        currentvalue={"prefix": "Start Index: "},
        pad={"t": 50},
        steps=steps
    )]

    fig.update_layout(
        sliders=sliders,
        title="Interactive Time Series Plot",
        xaxis_title="Time [ps]",
        yaxis_title=ylabel
    )

    fig.show()

def create_interactive_properties_plot(properties: dict, time_steps: np.ndarray, y_labels: dict):
    """
    Create an interactive plot with dropdown buttons to select different properties.
    Args:
        properties (dict): Dictionary containing the properties to plot.
        time_steps (np.ndarray): Array of time steps.
        y_labels (dict): Dictionary mapping property names to y-axis labels.
    """
    #### Build the figure ##################################################
    fig = go.Figure()

    all_props = list(properties.keys())
    for i, prop_name in enumerate(all_props):
        y_xtb = properties[prop_name]["xtb"]
        y_nn  = properties[prop_name]["nn"]
        
        # Add the XTB trace:
        fig.add_trace(
            go.Scatter(
                x=time_steps,
                y=y_xtb,
                mode="lines",
                name=f"XTB {prop_name}",
                visible=(i == 0),  # only the first property is visible at start
            )
        )
        # Add the NN trace:
        fig.add_trace(
            go.Scatter(
                x=time_steps,
                y=y_nn,
                mode="lines",
                name=f"NN {prop_name}",
                visible=(i == 0),
            )
        )

    #### Create dropdown buttons ###########################################
    buttons = []
    for i, prop_name in enumerate(all_props):
        # Build a visibility mask: 2 traces per property, so length = 2 * num_properties.
        visibility = [False] * (len(all_props) * 2)
        visibility[2*i]     = True  # XTB trace for this property
        visibility[2*i + 1] = True  # NN trace for this property

        buttons.append(
            dict(
                label=prop_name,
                method="update",
                args=[
                    {"visible": visibility},     # which traces to show
                    {
                        "title": {
                            "text": f"{prop_name} over Time",
                            "x": 0.5,
                            "xanchor": "center",
                        },
                        "yaxis": {
                            "title": {"text": y_labels[prop_name]}
                        }
                    },
                ],
            )
        )

    #### Initial layout ##################################################
    fig.update_layout(
        updatemenus=[
            dict(
                active=0,
                buttons=buttons,
                x=0.0,
                y=1.15,
                xanchor="left",
                yanchor="top",
                direction="down",
                pad={"r": 10, "t": 10},
                showactive=True,
            )
        ],
        title={
            "text": f"{all_props[0]} over Time",
            "x": 0.5,
            "xanchor": "center",
        },
        xaxis_title="Time [ps]",
        yaxis_title=y_labels[all_props[0]],  # e.g. “Energy [eV]” for “Potential Energy”
        margin={"t": 100},  # leave enough room at the top for dropdown + title
    )

    fig.show()

def create_interactive_window_scatter(xtb_e_pot: np.ndarray,
                                      nn_e_pot: np.ndarray,
                                      window_sizes: list):
    """
    Create an interactive Plotly scatter where:
      - A dropdown lets you pick one window size W from window_sizes.
      - A slider then controls the “first_config” index i, showing the scatter of
        xtb_e_pot[i : i+W] vs. nn_e_pot[i : i+W].

    Args:
        xtb_e_pot (np.ndarray): 1D array of XTB potential‐energy values.
        nn_e_pot  (np.ndarray): 1D array of NN  potential‐energy values.
        window_sizes (list of int): List of candidate window-sizes to choose from.
    """
    # Make sure the inputs are the same length:
    assert len(xtb_e_pot) == len(nn_e_pot), "xtb_e_pot and nn_e_pot must have equal length"
    n_points = len(xtb_e_pot)

    # Precompute, for each window_size W, the slider steps array
    # Each step: method="update", args[0] changes the trace’s "x" and "y" slices.
    sliders_for_W = {}
    for W in window_sizes:
        max_start = n_points - W  # last valid starting index is n_points - W
        steps = []
        for i in range(max_start + 1):
            start = i
            end = i + W
            slice_x = xtb_e_pot[start:end]
            slice_y = nn_e_pot[start:end]

            step = dict(
                method="update",
                args=[
                    # args[0]: update data of the single trace:
                    {
                        "x": [slice_x],
                        "y": [slice_y]
                    },
                    # args[1]: we update the title to show current window and indices:
                    {
                        "title": {
                            "text": f"Scatter (W={W}, i={start}…)​",
                            "x": 0.5,
                            "xanchor": "center"
                        }
                    }
                ],
                label=str(i)
            )
            steps.append(step)

        sliders_for_W[W] = [
            dict(
                active=0,
                currentvalue={"prefix": "start index: "},
                pad={"t": 50},
                steps=steps
            )
        ]

    # Create the figure and add one initial Scatter trace (using the first window_size)
    initial_W = window_sizes[0]
    init_slice_x = xtb_e_pot[0 : initial_W]
    init_slice_y = nn_e_pot[0 : initial_W]

    fig = go.Figure(
        data=[
            go.Scatter(
                x=init_slice_x,
                y=init_slice_y,
                mode="markers",
                marker={"size": 3, "color": "black", "opacity": 1.0},
                name=f"W={initial_W}"
            )
        ]
    )

    # Build dropdown buttons: each button swaps in the appropriate initial slice + slider
    buttons = []
    for W in window_sizes:
        # The “initial” slice for this W is i=0…W
        init_x = xtb_e_pot[0:W]
        init_y = nn_e_pot[0:W]

        buttons.append(
            dict(
                label=f"Window Size={W}",
                method="update",
                args=[
                    # args[0]: update the trace’s x/y to the new window’s i=0 slice
                    {
                        "x": [init_x],
                        "y": [init_y],
                        "marker": {"size": 3, "color": "black", "opacity": 1.0}
                    },
                    # args[1]: update layout → title & sliders
                    {
                        "title": {
                            "text": f"Scatter (W={W}, i=0…)",
                            "x": 0.5,
                            "xanchor": "center"
                        },
                        "sliders": sliders_for_W[W]
                    }
                ]
            )
        )

    # Attach dropdown and the initial slider to layout
    fig.update_layout(
        updatemenus=[
            dict(
                active=0,
                buttons=buttons,
                x=0.0,
                y=1.15,
                xanchor="left",
                yanchor="top",
                direction="down",
                pad={"r": 10, "t": 10},
                showactive=True
            )
        ],
        sliders=sliders_for_W[initial_W],  # attach the initial window_size’s slider
        title={
            "text": f"Scatter (W={initial_W}, i=0…)",
            "x": 0.5,
            "xanchor": "center"
        },
        xaxis_title="XTB Potential Energy [eV]",
        yaxis_title="NN  Potential Energy [eV]",
        margin={"t": 100}  # extra top margin for dropdown + title
    )

    fig.show()

def create_interactive_rolling_corr_plot(rolling_data: dict, window_sizes: list):
    """
    Create an interactive Plotly figure showing rolling correlations
    between XTB and NN for two properties (Potential and Kinetic energy)
    across multiple window sizes. A dropdown menu allows switching
    between properties, and each property’s subplot contains one trace
    per window size.
    
    Args:
        rolling_data (dict): Dictionary containing rolling correlation data.
        window_sizes (list of int): List of rolling‐window sizes.
    """
    
    
    # Now build the Plotly figure
    fig = go.Figure()
    all_props = ["Potential Energy", "Kinetic Energy"]
    
    # Add one trace per (property, window_size). We'll keep them all in the same figure,
    # but only make one property’s traces visible at a time.
    for i, prop_name in enumerate(all_props):
        for j, w in enumerate(window_sizes):
            t_arr, corr_arr = rolling_data[prop_name][j]
            fig.add_trace(
                go.Scatter(
                    x=t_arr,
                    y=corr_arr,
                    mode="lines",
                    name=f"Window {w}",
                    visible=(i == 0),  # Only show the first property’s traces initially
                    legendgroup=str(w),  # group legends by window size if desired
                )
            )
    
    # Create two dropdown buttons (one for each property)
    buttons = []
    num_windows = len(window_sizes)
    total_traces = len(all_props) * num_windows  # = 2 * len(window_sizes)
    
    for i, prop_name in enumerate(all_props):
        # Build a mask of length total_traces, turning on the i-th block of size num_windows
        visibility = [False] * total_traces
        start_index = i * num_windows
        for k in range(num_windows):
            visibility[start_index + k] = True
        
        buttons.append(
            dict(
                label=prop_name,
                method="update",
                args=[
                    {"visible": visibility},
                    {
                        "title": {
                            "text": f"Rolling Correlation: {prop_name}",
                            "x": 0.5,
                            "xanchor": "center"
                        },
                        "yaxis": {
                            "title": {"text": "Rolling Correlation"}
                        }
                    }
                ]
            )
        )
    
    # Final layout tweaks
    fig.update_layout(
        updatemenus=[
            dict(
                active=0,
                buttons=buttons,
                x=0.0,
                y=1.15,
                xanchor="left",
                yanchor="top",
                direction="down",
                pad={"r": 10, "t": 10},
                showactive=True
            )
        ],
        title={
            "text": f"Rolling Correlation: {all_props[0]}",
            "x": 0.5,
            "xanchor": "center"
        },
        xaxis_title="Time [ps]",
        yaxis_title="Rolling Correlation",
        margin={"t": 100}
    )
    
    fig.show()


def main(trajectory_dir: str, model_dir: str, simulation_name: str, n_samples: int, first_sample: int):
    ####################### 1) Compose the config ###########################
    with initialize(config_path="conf", job_name="inference", version_base="1.1"):
        cfg: DictConfig = compose(config_name="inference_config")

    # use training config to update the inference config
    train_cfg_path = os.path.join("runs", model_dir, "tensorboard/default/version_0")
    with initialize(config_path=train_cfg_path, job_name="train", version_base="1.1"):
        cfg_train: DictConfig = compose(config_name="hparams.yaml")
    cfg = update_config_with_train_config(cfg, cfg_train)

    ####################### 2) Prepare Data and Paths #########################
    home_dir = os.path.expanduser("~")
    md_workdir = os.path.join(home_dir, "whk/code/md_with_schnet/neural_net/runs", model_dir)
    print(f"md_workdir: {md_workdir}")
    print(f"simulation_name: {simulation_name}")
    target_dir = os.path.join(md_workdir, simulation_name)
    
    # read in the saved .traj files and save them as .xyz files
    xtb_traj = read(f'{target_dir}/xtb_traj.traj', index=':')
    nn_traj = read(f'{target_dir}/nn_traj.traj', index=':')
    write(f'{target_dir}/xtb_traj.xyz', xtb_traj)
    write(f'{target_dir}/nn_traj.xyz', nn_traj)

    # load the HDF5 file containing the MD simulation data
    xtb_data = np.loadtxt(f'{target_dir}/xtb_md.log', skiprows=1) 
    nn_data = np.loadtxt(f'{target_dir}/nn_md.log', skiprows=1) # time[ps], Etot, Epot, Ekin[eV], T[K]
    logger.debug(f"Shape of xtb_data: {xtb_data.shape}")
    logger.debug(f"Shape of nn_data: {nn_data.shape}")

    # take first n entries for plotting
    if n_samples + first_sample > xtb_data.shape[0]:
        raise ValueError(f"Requested n_samples ({n_samples}) + first_sample ({first_sample}) exceeds available data length ({xtb_data.shape[0]}).")
    xtb_data = xtb_data[first_sample:first_sample + n_samples, :]  # time[ps], Etot, Epot, Ekin[eV], T[K]
    nn_data = nn_data[first_sample:first_sample + n_samples, :]  # time[ps], Etot, Epot, Ekin[eV], T[K]

    # ase saves the time in ps
    time_steps = xtb_data[:, 0] 
    xtb_e_tot = xtb_data[:, 1]  
    xtb_e_pot = xtb_data[:, 2]  
    xtb_e_kin = xtb_data[:, 3]  
    xtb_temp = xtb_data[:, 4]  
    
    nn_e_tot = nn_data[:, 1]  
    nn_e_pot = nn_data[:, 2]  
    nn_e_kin = nn_data[:, 3]  
    nn_temp = nn_data[:, 4]  

    

    window_sizes = [100, 250, 500, 1000]
    
    # Create an interactive scatter plot with a dropdown for window sizes
    create_interactive_window_scatter(
        xtb_e_pot=xtb_e_pot,
        nn_e_pot=nn_e_pot,
        window_sizes=window_sizes
    )

    # set_plotting_config(fontsize=10, aspect_ratio=8/4, width_fraction=1)
    # plt.figure()
    # # make small marker size
    # plt.scatter(xtb_e_pot[first_config:window_sizes[0]], nn_e_pot[first_config:window_sizes[0]], color='purple', marker='.', s=1)
    # plt.xlabel('XTB Potential Energy [eV]')
    # plt.ylabel('NN Potential Energy [eV]')
    # plt.title('Potential Energy Comparison')
    # plt.tight_layout()
    # plt.show()

    exit()

    # Build two pandas DataFrames so we can call .rolling().corr()
    xtb_df = pd.DataFrame({
        'time': time_steps,
        'e_pot': xtb_e_pot,
        'e_kin': xtb_e_kin
    })
    
    nn_df = pd.DataFrame({
        'time': time_steps,
        'e_pot': nn_e_pot,
        'e_kin': nn_e_kin
    })
    
    # We'll store, for each property, the list of (time_array, corr_array) tuples,
    # one entry per window_size.
    rolling_data = {
        "Potential Energy": [],
        "Kinetic Energy": []
    }
    
    for w in window_sizes:
        # Compute the full rolling‐pairwise correlation. This produces a MultiIndex:
        # first level = original index (time), second level = column name.
        # We only need the off‐diagonal (between e_pot of xtb_df and e_pot of nn_df), etc.
        # However, pandas' rolling().corr() of two DataFrames lines up columns automatically.
        corr_df = xtb_df['e_pot'].rolling(window=w).corr(nn_df['e_pot']).dropna()
        corr_df_kin = xtb_df['e_kin'].rolling(window=w).corr(nn_df['e_kin']).dropna()

        # new time steps = time steps - window_size + 1
        time_corr = time_steps[:-(w-1)]
        
        rolling_data["Potential Energy"].append((time_corr, corr_df.values))
        rolling_data["Kinetic Energy"].append((time_corr, corr_df_kin.values))


    create_interactive_rolling_corr_plot(
        rolling_data=rolling_data,
        window_sizes=window_sizes
    )

    
    exit()

    #### Prepare data for interactive plotting ##############################
    # scale total energies to [0, 1] range for better visualization
    xtb_e_tot_scaled = (xtb_e_tot - np.min(xtb_e_tot)) / (np.max(xtb_e_tot) - np.min(xtb_e_tot))
    nn_e_tot_scaled = (nn_e_tot - np.min(nn_e_tot)) / (np.max(nn_e_tot) - np.min(nn_e_tot))

    # Define properties
    properties = {
        "Total Energy": {"xtb": xtb_e_tot, "nn": nn_e_tot},
        "Scaled Total Energy": {"xtb": xtb_e_tot_scaled, "nn": nn_e_tot_scaled},
        "Potential Energy": {"xtb": xtb_e_pot, "nn": nn_e_pot},
        "Kinetic Energy": {"xtb": xtb_e_kin, "nn": nn_e_kin},
        "Temperature": {"xtb": xtb_temp, "nn": nn_temp},
    }

    # A small lookup table for y-axis labels:
    y_labels = {
        "Total Energy": "Energy [eV]",
        "Scaled Total Energy": "Normalized Value",
        "Potential Energy": "Energy [eV]",
        "Kinetic Energy": "Energy [eV]",
        "Temperature": "Temperature [K]",
    }

    # Create interactive plot with dropdown
    create_interactive_properties_plot(
        properties=properties,
        time_steps=time_steps,
        y_labels=y_labels
    )


    exit()

    # log available properties
    log_properties = [prop for prop in data.properties]
    logger.info(f"Available properties in the HDF5 file:\n{log_properties}")

    
    # Get the energy logged via PropertiesStream
    energies_calculator = data.get_property(properties.energy, atomistic=False)
    # Get potential energies stored in the MD system
    energies_system = data.get_potential_energy()

    # Check the overall shape
    logger.debug(f"Shape: {energies_system.shape}")
    logger.debug(f"data.entries: {data.entries}")
    logger.debug(f"data.time_step (in atomic units): {data.time_step}")


    # Convert the system potential energy from internal units (kJ/mol) to Hartree
    energies_system *= spk_units.convert_units("kJ/mol", "Hartree")

    # Plot the energies
    #plot_energies_system_vs_calculator(data, energies_system, energies_calculator)
    logger.debug(f"Min energy: {np.min(energies_system)} Hartree")
    logger.debug(f"Max energy: {np.max(energies_system)} Hartree")
    
    
    ####################### 2) Prepare Data and Paths #########################
    data_prefix = set_data_prefix()
    model_path = cfg.globals.model_path
    md_workdir = cfg.run.path

    split_file = os.path.join(data_prefix, "splits", trajectory_dir, "inner_splits_0.npz")
    if not os.path.exists(split_file):
        raise FileNotFoundError(f"Missing split file: {split_file}")
    path_to_db = os.path.join(data_prefix, trajectory_dir, "md_trajectory.db")
    logger.debug(f"Path to database: {path_to_db}")

    datamodule = load_xtb_dataset(path_to_db, cfg, split_file)
    # Plot energies of the actual testdata
    test_data = datamodule.test_dataset
    test_energies = []
    for i, d in enumerate(test_data):
        if i >= 200:
            break
        test_energies.append(d["energy"])
    test_energies = np.array(test_energies)
    plot_energies(data, test_energies, energies_system)
    exit()

    
    # Plot the temperature
    plot_temperature(data)
    logger.debug(f"Min temperature: {np.min(data.get_temperature())} K")
    logger.debug(f"Max temperature: {np.max(data.get_temperature())} K")

    # extract structure information from HDF5 data
    trajectory_path = os.path.join(md_workdir, "trajectory.xyz")
    if not os.path.exists(trajectory_path):
        md_atoms = data.convert_to_atoms()

        # write list of Atoms to XYZ file
        write(
            trajectory_path,
            md_atoms,
            format="xyz"
        )

    # Initialize the spectrum
    equilibrated_data = HDF5Loader(log_file, skip_initial=10000) # i.e. skip first half
    spectrum = PowerSpectrum(equilibrated_data, resolution=2048)

    # Compute the spectrum for the first molecule (default)
    spectrum.compute_spectrum(molecule_idx=0)

    # Get frequencies and intensities
    frequencies, intensities = spectrum.get_spectrum()

    plot_spectrum(frequencies, intensities)

    



if __name__ == "__main__":
    args = parse_args()
    main(**args)


# code for non interactive plotting
# # plot potential energies from xtb and nn
# set_plotting_config(fontsize=10, aspect_ratio=468/525, width_fraction=1)
# fig, axes = plt.subplots(3) 
# axes[0].plot(time_steps, xtb_e_tot, label='XTB Total Energy', color='green')
# axes[0].plot(time_steps, nn_e_tot, label='NN Total Energy', color='red')
# axes[0].set_xlabel('Time [ps]')
# axes[0].set_ylabel('Total Energy [eV]')
# axes[0].set_title('Total Energy Comparison')
# axes[0].legend()
# axes[1].plot(time_steps, xtb_e_pot, label='XTB Potential Energy', color='cyan')
# axes[1].plot(time_steps, nn_e_pot, label='NN Potential Energy', color='magenta')
# axes[1].set_xlabel('Time [ps]')
# axes[1].set_ylabel('Potential Energy [eV]')
# axes[1].set_title('Potential Energy Comparison')
# axes[1].legend()
# axes[2].plot(time_steps, xtb_e_kin, label='XTB Kinetic Energy', color='purple')
# axes[2].plot(time_steps, nn_e_kin, label='NN Kinetic Energy', color='brown')
# axes[2].set_xlabel('Time [ps]')
# axes[2].set_ylabel('Kinetic Energy [eV]')
# axes[2].set_title('Kinetic Energy Comparison')
# axes[2].legend()
# plt.tight_layout()
# plt.show()

# # plot potential energies on twin axes
# set_plotting_config(fontsize=10, aspect_ratio=8/4, width_fraction=1)
# fig, ax1 = plt.subplots()
# ax1.plot(time_steps, xtb_e_pot, label='XTB Potential Energy', color='green')
# ax2 = ax1.twinx()  # create a twin Axes sharing the x-axis
# ax2.plot(time_steps, nn_e_pot, label='NN Potential Energy', color='red')
# ax1.set_xlabel('Time [ps]')
# ax1.set_ylabel('XTB Potential Energy [eV]', color='green')
# ax2.set_ylabel('NN Potential Energy [eV]', color='red')
# ax1.set_title('Potential Energy Comparison')
# ax1.tick_params(axis='y', labelcolor='green')
# ax2.tick_params(axis='y', labelcolor='red')
# # Combine legends from both axes
# lines, labels = ax1.get_legend_handles_labels()
# lines2, labels2 = ax2.get_legend_handles_labels()
# ax1.legend(lines + lines2, labels + labels2, loc='upper left')
# plt.tight_layout()
# plt.show()

# # compute rolling correlation with pandas
# xtb_df = pd.DataFrame({
#     'time': time_steps,
#     'e_pot': xtb_e_pot,
#     'e_kin': xtb_e_kin,
#     'temp': xtb_temp
# })
# nn_df = pd.DataFrame({
#     'time': time_steps,
#     'e_pot': nn_e_pot,
#     'e_kin': nn_e_kin,
#     'temp': nn_temp
# })
# # compute rolling correlation with a window of 100
# window_sizes = [100, 250, 500]
# # take first four colors from the default matplotlib color cycle
# colors = plt.rcParams['axes.prop_cycle'].by_key()['color'][:len(window_sizes)]

# xtb_nn_corrs = []
# xtb_nn_time = []
# for window_size in window_sizes:
#     xtb_nn_corr = xtb_df.rolling(window=window_size).corr(nn_df)
#     xtb_nn_corr = xtb_nn_corr.dropna()
#     xtb_nn_corrs.append(xtb_nn_corr)
#     # new time steps = time steps - window_size + 1
#     xtb_nn_time.append(xtb_df['time'][:-(window_size-1)]) 
#     logger.debug(f"XTB correlation shape: {xtb_nn_corr.shape}")

# # plot the rolling correlation
# set_plotting_config(fontsize=10, aspect_ratio=8/4, width_fraction=1)
# plt.figure()
# for i, window_size in enumerate(window_sizes):
#     xtb_nn_corr = xtb_nn_corrs[i]
#     xtb_nn_time_i = xtb_nn_time[i]
#     xtb_nn_time_i = xtb_nn_time[i]
#     plt.plot(xtb_nn_time_i, xtb_nn_corr['e_pot'], label=f'Window Size {window_size}', color=colors[i])
# plt.xlabel('Time [ps]')
# plt.ylabel('Rolling Correlation')
# plt.title('Rolling Correlation between XTB and NN Potential Energies')
# plt.legend()
# plt.tight_layout()
# plt.show()
