import os
import argparse
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

from hydra import initialize, compose
from omegaconf import OmegaConf, DictConfig
from schnetpack import properties
from schnetpack import units as spk_units
from schnetpack.md.data import HDF5Loader, PowerSpectrum
from ase.io import write, read


from md_with_schnet.utils import set_data_prefix, set_plotting_config, load_xtb_dataset
from md_with_schnet.setup_logger import setup_logger
from md_with_schnet.neural_net.inference_with_ase import update_config_with_train_config

# for interactive plotting
import plotly.graph_objects as go

logger = setup_logger("debug")

# Example command to run the script from within code directory:
"""
python -m md_with_schnet.neural_net.analyze_md_ase_sim --model_dir MOTOR_MD_XTB_T300_1_epochs_1000_bs_100_lr_0.0001_seed_42 --simulation_name  md_sim_steps_5000_time_step_1.0_seed_42 --n_samples 200
"""

def parse_args() -> dict:
    """ 
    Parse command-line arguments. 
    Returns:
        dict: Dictionary containing command-line arguments.
    """
    parser = argparse.ArgumentParser(description="Script for analyzing the trajectory predicted with the trained model on XTB test data.")
    # paths setup
    parser.add_argument("--trajectory_dir", type=str, default="MOTOR_MD_XTB/T300_1", help="Directory containing the trajectory data generated by Turbomole (default: MOTOR_MD_XTB/T300_1)")
    parser.add_argument("-mdir", "--model_dir", type=str, default="MOTOR_MD_XTB_T300_1_epochs_1000_bs_100_lr_0.0001_seed_42", help="Directory of the trained model (default: MOTOR_MD_XTB_T300_1_epochs_1000_bs_100_lr_0.0001_seed_42)")
    parser.add_argument("-sn", "--simulation_name", type=str, default="md_sim_steps_10000_time_step_0.5_seed_42", help="Name of the MD simulation (default: md_sim_steps_2000_time_step_0.5_seed_42)")
    # analysis setup
    parser.add_argument("-ns", "--n_samples", type=int, default=100, help="Number of samples to analyze (default: 1000)")
    parser.add_argument("-fs", "--first_sample", type=int, default=0, help="First sample to analyze (default: 0)")
    return vars(parser.parse_args())

def plot_energies_system_vs_calculator(data: HDF5Loader, energies_system: np.ndarray, energies_calculator: np.ndarray):
    """ Plot the energies of the system and the calculator.
    Args:
        data (HDF5Loader): HDF5Loader object containing the MD simulation data.
        energies_system (np.ndarray): Energies of the system.
        energies_calculator (np.ndarray): Energies of the calculator.
    """
    # Get the time axis in femtoseconds
    time_axis = np.arange(data.entries) * data.time_step / spk_units.fs 

    set_plotting_config()
    plt.figure()
    plt.plot(time_axis, energies_system, label=r"E$_\mathrm{pot}$ (System)")
    plt.plot(time_axis, energies_calculator, label=r"E$_\mathrm{pot}$ (Logger)", ls="--")
    plt.ylabel("E [Hartree]")
    plt.xlabel("t [fs]")
    plt.xlim(9800,10000)
    plt.legend()
    plt.tight_layout()
    plt.show()

def plot_energies(data: HDF5Loader, true_energies: np.ndarray, predicted_energies: np.ndarray):
    """ Plot the energies of the system and the calculator.
    Args:
        data (HDF5Loader): HDF5Loader object containing the MD simulation data.
        true_energies (np.ndarray): Energies of the calculator.
        predicted_energies (np.ndarray): Energies of the system.
    """
    # Get the time axis in femtoseconds
    time_axis = np.arange(data.entries) * data.time_step / spk_units.fs 
    time_axis = time_axis[:len(true_energies)]
    predicted_energies = predicted_energies[:len(true_energies)]

    set_plotting_config()
    plt.figure()
    
    # Plot true energies
    ax1 = plt.gca()
    line1, = ax1.plot(time_axis, true_energies, label=r"True $E_\mathrm{pot}$", color='tab:orange')
    ax1.set_ylabel("E [Hartree]", color='tab:orange')
    ax1.tick_params(axis='y', labelcolor='tab:orange')

    # Plot predicted energies on the twin axis
    ax2 = ax1.twinx()
    line2, = ax2.plot(time_axis, predicted_energies, label=r"Predicted $E_\mathrm{pot}$", color='tab:blue')
    ax2.set_ylabel("E [Hartree]", color='tab:blue')
    ax2.tick_params(axis='y', labelcolor='tab:blue')

    ax1.set_xlabel("Time [fs]")

    # Create a combined legend
    lines = [line1, line2]
    labels = [line.get_label() for line in lines]
    ax1.legend(lines, labels, loc='upper right')

    #plt.legend()
    plt.tight_layout()
    plt.show()

def plot_temperature(data: HDF5Loader):
    """ Plot the temperature of the system.
    Args:
        data (HDF5Loader): HDF5Loader object containing the MD simulation data.
    """
    set_plotting_config()

    # Read the temperature
    temperature = data.get_temperature()

    # Compute the cumulative mean
    temperature_mean = np.cumsum(temperature) / (np.arange(data.entries)+1)

    # Get the time axis
    time_axis = np.arange(data.entries) * data.time_step / spk_units.fs  # in fs

    plt.figure(figsize=(8,4))
    plt.plot(time_axis, temperature, label='T')
    plt.plot(time_axis, temperature_mean, label='T (avg.)')
    plt.ylabel('T [K]')
    plt.xlabel('t [fs]')
    plt.legend()
    plt.tight_layout()
    plt.show()

def plot_spectrum(frequencies: np.ndarray, intensities: np.ndarray):
    """ Plot the spectrum.
    Args:
        frequencies (np.ndarray): Frequencies of the spectrum.
        intensities (np.ndarray): Intensities of the spectrum.
    """
    set_plotting_config()
    # Plot the spectrum
    plt.figure()
    plt.plot(frequencies, intensities)
    plt.xlim(0,4000)
    plt.ylim(0,100)
    plt.ylabel('I [a.u.]')
    plt.xlabel(r'$\omega$ [cm$^{-1}$]')
    plt.show()


def create_interactive_plot(x: np.ndarray, y1: np.ndarray, y2: np.ndarray, ylabel: str, name_1: str, name_2: str, window_size: int = 200):
    fig = go.Figure()

    # Add initial traces
    fig.add_trace(go.Scatter(x=x[:window_size], y=y1[:window_size], mode='lines', name=name_1))
    fig.add_trace(go.Scatter(x=x[:window_size], y=y2[:window_size], mode='lines', name=name_2))

    # Create steps for the slider
    steps = []
    num_windows = len(x) - window_size + 1
    for i in range(num_windows):
        step = dict(
            method="update",
            args=[{"x": [x[i:i+window_size], x[i:i+window_size]],
                "y": [y1[i:i+window_size], y2[i:i+window_size]]},
                {"title": f"Time Series Window: {i} to {i+window_size}"}],
            label=str(i)
        )
        steps.append(step)

    # Create sliders
    sliders = [dict(
        active=0,
        currentvalue={"prefix": "Start Index: "},
        pad={"t": 50},
        steps=steps
    )]

    fig.update_layout(
        sliders=sliders,
        title="Interactive Time Series Plot",
        xaxis_title="Time [ps]",
        yaxis_title=ylabel
    )

    fig.show()

def main(trajectory_dir: str, model_dir: str, simulation_name: str, n_samples: int, first_sample: int):
    ####################### 1) Compose the config ###########################
    with initialize(config_path="conf", job_name="inference", version_base="1.1"):
        cfg: DictConfig = compose(config_name="inference_config")

    # use training config to update the inference config
    train_cfg_path = os.path.join("runs", model_dir, "tensorboard/default/version_0")
    with initialize(config_path=train_cfg_path, job_name="train", version_base="1.1"):
        cfg_train: DictConfig = compose(config_name="hparams.yaml")
    cfg = update_config_with_train_config(cfg, cfg_train)

    ####################### 2) Prepare Data and Paths #########################
    home_dir = os.path.expanduser("~")
    md_workdir = os.path.join(home_dir, "whk/code/md_with_schnet/neural_net/runs", model_dir)
    print(f"md_workdir: {md_workdir}")
    print(f"simulation_name: {simulation_name}")
    target_dir = os.path.join(md_workdir, simulation_name)
    
    # read in the saved .traj files and save them as .xyz files
    xtb_traj = read(f'{target_dir}/xtb_traj.traj', index=':')
    nn_traj = read(f'{target_dir}/nn_traj.traj', index=':')
    write(f'{target_dir}/xtb_traj.xyz', xtb_traj)
    write(f'{target_dir}/nn_traj.xyz', nn_traj)

    # load the HDF5 file containing the MD simulation data
    xtb_data = np.loadtxt(f'{target_dir}/xtb_md.log', skiprows=1) 
    nn_data = np.loadtxt(f'{target_dir}/nn_md.log', skiprows=1) # time[ps], Etot, Epot, Ekin[eV], T[K]
    logger.debug(f"Shape of xtb_data: {xtb_data.shape}")
    logger.debug(f"Shape of nn_data: {nn_data.shape}")

    # take first 100 entries for plotting
    if n_samples + first_sample > xtb_data.shape[0]:
        raise ValueError(f"Requested n_samples ({n_samples}) + first_sample ({first_sample}) exceeds available data length ({xtb_data.shape[0]}).")
    xtb_data = xtb_data[first_sample:first_sample + n_samples, :]  # time[ps], Etot, Epot, Ekin[eV], T[K]
    nn_data = nn_data[first_sample:first_sample + n_samples, :]  # time[ps], Etot, Epot, Ekin[eV], T[K]

    time_steps = xtb_data[:, 0]  # time in ps
    xtb_e_tot = xtb_data[:, 1]  
    xtb_e_pot = xtb_data[:, 2]  
    xtb_e_kin = xtb_data[:, 3]  
    xtb_temp = xtb_data[:, 4]  
    
    nn_e_tot = nn_data[:, 1]  
    nn_e_pot = nn_data[:, 2]  
    nn_e_kin = nn_data[:, 3]  
    nn_temp = nn_data[:, 4]  


    # plot potential energies from xtb and nn
    set_plotting_config(fontsize=10, aspect_ratio=468/525, width_fraction=1)
    fig, axes = plt.subplots(3) 
    axes[0].plot(time_steps, xtb_e_tot, label='XTB Total Energy', color='green')
    axes[0].plot(time_steps, nn_e_tot, label='NN Total Energy', color='red')
    axes[0].set_xlabel('Time [ps]')
    axes[0].set_ylabel('Total Energy [eV]')
    axes[0].set_title('Total Energy Comparison')
    axes[0].legend()
    axes[1].plot(time_steps, xtb_e_pot, label='XTB Potential Energy', color='cyan')
    axes[1].plot(time_steps, nn_e_pot, label='NN Potential Energy', color='magenta')
    axes[1].set_xlabel('Time [ps]')
    axes[1].set_ylabel('Potential Energy [eV]')
    axes[1].set_title('Potential Energy Comparison')
    axes[1].legend()
    axes[2].plot(time_steps, xtb_e_kin, label='XTB Kinetic Energy', color='purple')
    axes[2].plot(time_steps, nn_e_kin, label='NN Kinetic Energy', color='brown')
    axes[2].set_xlabel('Time [ps]')
    axes[2].set_ylabel('Kinetic Energy [eV]')
    axes[2].set_title('Kinetic Energy Comparison')
    axes[2].legend()
    plt.tight_layout()
    plt.show()

    # plot potential energies on twin axes
    set_plotting_config(fontsize=10, aspect_ratio=8/4, width_fraction=1)
    fig, ax1 = plt.subplots()
    ax1.plot(time_steps, xtb_e_pot, label='XTB Potential Energy', color='green')
    ax2 = ax1.twinx()  # create a twin Axes sharing the x-axis
    ax2.plot(time_steps, nn_e_pot, label='NN Potential Energy', color='red')
    ax1.set_xlabel('Time [ps]')
    ax1.set_ylabel('XTB Potential Energy [eV]', color='green')
    ax2.set_ylabel('NN Potential Energy [eV]', color='red')
    ax1.set_title('Potential Energy Comparison')
    ax1.tick_params(axis='y', labelcolor='green')
    ax2.tick_params(axis='y', labelcolor='red')
    # Combine legends from both axes
    lines, labels = ax1.get_legend_handles_labels()
    lines2, labels2 = ax2.get_legend_handles_labels()
    ax1.legend(lines + lines2, labels + labels2, loc='upper left')
    plt.tight_layout()
    plt.show()

    set_plotting_config(fontsize=10, aspect_ratio=8/4, width_fraction=1)
    plt.figure()
    # make small marker size
    plt.scatter(xtb_e_pot, nn_e_pot, color='purple', marker='.', s=1)
    plt.xlabel('XTB Potential Energy [eV]')
    plt.ylabel('NN Potential Energy [eV]')
    plt.title('Potential Energy Comparison')
    plt.tight_layout()
    plt.show()

    # compute rolling correlation with pandas
    xtb_df = pd.DataFrame({
        'time': time_steps,
        'e_pot': xtb_e_pot,
        'e_kin': xtb_e_kin,
        'temp': xtb_temp
    })
    nn_df = pd.DataFrame({
        'time': time_steps,
        'e_pot': nn_e_pot,
        'e_kin': nn_e_kin,
        'temp': nn_temp
    })
    # compute rolling correlation with a window of 100
    window_size = 200
    xtb_nn_corr = xtb_df.rolling(window=window_size).corr(nn_df).dropna()
    logger.debug(f"XTB correlation shape: {xtb_nn_corr.shape}")
    # plot the rolling correlation
    set_plotting_config(fontsize=10, aspect_ratio=8/4, width_fraction=1)
    plt.figure()
    plt.plot(xtb_nn_corr['e_pot'], label='Potential Energies Correlation', color='green')
    plt.plot(xtb_nn_corr['e_kin'], label='Kinetic Energies Correlation', color='red')
    plt.xlabel('Time [ps]')
    plt.ylabel('Rolling Correlation')
    plt.title('Rolling Correlation between XTB and NN Energies')
    plt.legend()
    plt.tight_layout()
    plt.show()


    create_interactive_plot(
        x=time_steps,
        y1=xtb_e_pot,
        y2=nn_e_pot,
        ylabel="Potential Energy [eV]",
        name_1="XTB Potential Energy",
        name_2="NN Potential Energy",
        window_size=200
    )


    exit()

    # log available properties
    log_properties = [prop for prop in data.properties]
    logger.info(f"Available properties in the HDF5 file:\n{log_properties}")

    
    # Get the energy logged via PropertiesStream
    energies_calculator = data.get_property(properties.energy, atomistic=False)
    # Get potential energies stored in the MD system
    energies_system = data.get_potential_energy()

    # Check the overall shape
    logger.debug(f"Shape: {energies_system.shape}")
    logger.debug(f"data.entries: {data.entries}")
    logger.debug(f"data.time_step (in atomic units): {data.time_step}")


    # Convert the system potential energy from internal units (kJ/mol) to Hartree
    energies_system *= spk_units.convert_units("kJ/mol", "Hartree")

    # Plot the energies
    #plot_energies_system_vs_calculator(data, energies_system, energies_calculator)
    logger.debug(f"Min energy: {np.min(energies_system)} Hartree")
    logger.debug(f"Max energy: {np.max(energies_system)} Hartree")
    
    
    ####################### 2) Prepare Data and Paths #########################
    data_prefix = set_data_prefix()
    model_path = cfg.globals.model_path
    md_workdir = cfg.run.path

    split_file = os.path.join(data_prefix, "splits", trajectory_dir, "inner_splits_0.npz")
    if not os.path.exists(split_file):
        raise FileNotFoundError(f"Missing split file: {split_file}")
    path_to_db = os.path.join(data_prefix, trajectory_dir, "md_trajectory.db")
    logger.debug(f"Path to database: {path_to_db}")

    datamodule = load_xtb_dataset(path_to_db, cfg, split_file)
    # Plot energies of the actual testdata
    test_data = datamodule.test_dataset
    test_energies = []
    for i, d in enumerate(test_data):
        if i >= 200:
            break
        test_energies.append(d["energy"])
    test_energies = np.array(test_energies)
    plot_energies(data, test_energies, energies_system)
    exit()

    
    # Plot the temperature
    plot_temperature(data)
    logger.debug(f"Min temperature: {np.min(data.get_temperature())} K")
    logger.debug(f"Max temperature: {np.max(data.get_temperature())} K")

    # extract structure information from HDF5 data
    trajectory_path = os.path.join(md_workdir, "trajectory.xyz")
    if not os.path.exists(trajectory_path):
        md_atoms = data.convert_to_atoms()

        # write list of Atoms to XYZ file
        write(
            trajectory_path,
            md_atoms,
            format="xyz"
        )

    # Initialize the spectrum
    equilibrated_data = HDF5Loader(log_file, skip_initial=10000) # i.e. skip first half
    spectrum = PowerSpectrum(equilibrated_data, resolution=2048)

    # Compute the spectrum for the first molecule (default)
    spectrum.compute_spectrum(molecule_idx=0)

    # Get frequencies and intensities
    frequencies, intensities = spectrum.get_spectrum()

    plot_spectrum(frequencies, intensities)

    



if __name__ == "__main__":
    args = parse_args()
    main(**args)