import os
import argparse
import torch
import schnetpack as spk

import schnetpack.transform as trn

from hydra import initialize, compose
from omegaconf import OmegaConf, DictConfig

from ase import Atoms
from schnetpack import properties
from schnetpack.md import System, UniformInit, Simulator
from schnetpack.md.integrators import VelocityVerlet
from schnetpack.md.neighborlist_md import NeighborListMD
from schnetpack.transform import ASENeighborList
from schnetpack.md.calculators import SchNetPackCalculator
from schnetpack.md.simulation_hooks import LangevinThermostat, callback_hooks

from schnetpack.utils import load_model


from md_with_schnet.utils import set_data_prefix, load_xtb_dataset
from md_with_schnet.setup_logger import setup_logger


# Example command to run the script from within code directory:
"""
screen -dmS inference_xtb sh -c 'python -m md_with_schnet.neural_net.inference --trajectory_dir MOTOR_MD_XTB/T300_1 ; exec bash'
"""

logger = setup_logger("debug")

def parse_args() -> dict:
    """ Parse command-line arguments. 

    Returns:
        dict: Dictionary containing command-line arguments.
    """
    parser = argparse.ArgumentParser(description="Script for predicting with trained model on XTB test data.")
    # paths setup
    parser.add_argument("--trajectory_dir", type=str, default="MOTOR_MD_XTB/T300_1", help="Directory containing the trajectory data generated by Turbomole (default: MOTOR_MD_XTB/T300_1)")
    return vars(parser.parse_args())

def main(trajectory_dir: str):
    ####################### 1) Compose the config ###########################
    with initialize(config_path="conf", job_name="train"):
        cfg: DictConfig = compose(config_name="my_config")
    logger.info(f"Loaded config:\n{OmegaConf.to_yaml(cfg)}")

    ####################### 2) Prepare our own data #########################
    data_prefix = set_data_prefix()
    model_path = os.path.join(data_prefix, "output", "best_inference_model") # location of best model
    md_workdir = f'{data_prefix}/md_workdir'
    os.makedirs(md_workdir, exist_ok=True)

    splits_dir = os.path.join(data_prefix, "splits", trajectory_dir)
    split_file = os.path.join(splits_dir, "inner_splits_0.npz")
    if not os.path.exists(split_file):
        raise FileNotFoundError(f"Missing split file: {split_file}")
    path_to_db = os.path.join(data_prefix, trajectory_dir, "md_trajectory.db")

    datamodule = load_xtb_dataset(path_to_db, cfg, split_file)

    # set up converter
    # check if a GPU is available and use a CPU otherwise
    if torch.cuda.is_available():
        device = "cuda"
    else:
        device = "cpu"
    best_model = torch.load(model_path, map_location=device)
    converter = spk.interfaces.AtomsConverter(
        neighbor_list=trn.ASENeighborList(cutoff=5.0), dtype=torch.float32, device=device
    )

    # create atoms object from dataset
    structure = datamodule.test_dataset[0]
    atoms = Atoms(
        numbers=structure[spk.properties.Z], positions=structure[spk.properties.R]
    )

    # convert atoms to SchNetPack inputs and perform prediction
    inputs = converter(atoms)
    results = best_model(inputs)

    exit()
    


    ### SETUP THE MOLECULAR DYNAMICS SIMULATION ###
    # Number of molecular replicas
    n_replicas = 1
    system_temperature = 300 # Kelvin
    time_step = 0.5 # fs
    # set cutoff and buffer region for neighbor list
    cutoff = 5.0  # Angstrom (units used in model)
    cutoff_shell = 2.0  # Angstrom
    md_precision = torch.float32
    # Set thermostat constant
    time_constant = 100  # fs
    # Size of the buffer for the file logger
    buffer_size = 100
    # Number of steps to simulate
    n_steps = 20000

    # set up MD system
    md_system = System()
    md_system.load_molecules(
        molecule, 
        n_replicas=n_replicas, 
        position_unit_input="Angstrom"
        )
    
    # Set up the initializer
    md_initializer = UniformInit(
        system_temperature,
        remove_center_of_mass=True,
        remove_translation=True,
        remove_rotation=True,
    )

    # Initialize the system momenta
    md_initializer.initialize_system(md_system)

    # Set up the integrator
    md_integrator = VelocityVerlet(time_step)
        
    # initialize neighbor list for MD using the ASENeighborlist as basis
    md_neighborlist = NeighborListMD(
        cutoff,
        cutoff_shell,
        ASENeighborList,
    )

    md_calculator = SchNetPackCalculator(
        model_path,  # path to stored model
        "forces",  # force key
        "Hartree",  # energy units
        "Angstrom",  # length units
        md_neighborlist,  # neighbor list
        energy_key="energy",  # name of potential energies
        required_properties=[],  # additional properties extracted from the model
    )

    # Initialize the thermostat and set it as a simulation hook
    langevin = LangevinThermostat(system_temperature, time_constant)
    simulation_hooks = [langevin]

    # Path to database
    log_file = os.path.join(md_workdir, "simulation_schnet.hdf5")

    # Set up data streams to store positions, momenta and the energy
    data_streams = [
        callback_hooks.MoleculeStream(store_velocities=True),
        callback_hooks.PropertyStream(target_properties=[properties.energy]),
    ]

    # Create the file logger
    file_logger = callback_hooks.FileLogger(
        log_file,
        buffer_size,
        data_streams=data_streams,
        every_n_steps=1,  # logging frequency
        precision=32,  # floating point precision used in hdf5 database
    )

    # Update the simulation hooks
    simulation_hooks.append(file_logger)

    # Set the path to the checkpoint file and create checkpoint logger
    chk_file = os.path.join(md_workdir, 'simulation.chk')
    checkpoint = callback_hooks.Checkpoint(chk_file, every_n_steps=100)
    # Update the simulation hooks
    simulation_hooks.append(checkpoint)

    # directory where tensorboard log will be stored to
    tensorboard_dir = os.path.join(md_workdir, 'logs')
    tensorboard_logger = callback_hooks.TensorBoardLogger(
        tensorboard_dir,
        ["energy", "temperature"], # properties to log
    )
    # update simulation hooks
    simulation_hooks.append(tensorboard_logger)

    # Set up the MD simulator
    md_simulator = Simulator(md_system, md_integrator, md_calculator, simulator_hooks=simulation_hooks)
    md_simulator = md_simulator.to(md_precision)
    md_simulator = md_simulator.to(device)

    # Simulate the MD system
    md_simulator.simulate(n_steps)

if __name__ == "__main__":
    args = parse_args()
    main(**args)