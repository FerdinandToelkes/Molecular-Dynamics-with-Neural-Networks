import os
import argparse
import schnetpack as spk
import platform
import time
import logging
import torch

from hydra.utils import instantiate
from omegaconf import OmegaConf, DictConfig
from ase import Atoms
from ase.md.verlet import VelocityVerlet as ASEVelocityVerlet
from ase.io import read, write
from xtb_ase import XTB
from tqdm import tqdm

from md_with_schnet.utils import set_data_prefix, get_split_path, load_config, setup_datamodule
from md_with_schnet.setup_logger import setup_logger
from md_with_schnet.units import convert_time, convert_velocities, get_ase_units_from_str

# Example command to run the script from within code directory:
"""
screen -dmS inference_xtb sh -c 'python -m md_with_schnet.neural_net.inference_with_ase -mdir MOTOR_MD_XTB_T300_1_ang_kcal_mol_epochs_1000_bs_100_lr_0.0001_seed_42 --md_steps 100 -ts 0.5 ; exec bash'
"""


logger = setup_logger("debug")

def parse_args() -> dict:
    """ Parse command-line arguments. 

    Returns:
        dict: Dictionary containing command-line arguments.
    """
    parser = argparse.ArgumentParser(description="Script for predicting with trained model on XTB test data.")
    # paths setup
    parser.add_argument("--trajectory_dir", type=str, default="MOTOR_MD_XTB/T300_1", help="Directory containing the trajectory data generated by Turbomole (default: MOTOR_MD_XTB/T300_1)")
    parser.add_argument("--units", type=str, default="angstrom_kcal_per_mol_fs", choices=["angstrom_kcal_per_mol_fs", "angstrom_ev_fs", "bohr_hartree_aut"], help="Units for the input data (default: angstrom_kcal_per_mol_fs).")
    parser.add_argument("-mdir", "--model_dir", type=str, default="epochs_1000_bs_100_lr_0.0001_seed_42", help="Directory of the trained model (default: epochs_1000_bs_100_lr_0.0001_seed_42)")
    parser.add_argument("-mds", "--md_steps", type=int, default=10, help="Number of MD steps to run (default: 10)")
    parser.add_argument("-ts", "--time_step", type=float, default=0.5, help="Time step for the MD simulation in fs (default: 0.5 fs)")
    parser.add_argument("-f", "--fold", type=int, default=0, help="Fold number for cross-validation (default: 0)")
    parser.add_argument("-s", "--seed", type=int, default=42, help="Random seed for reproducibility (default: 42)")
    parser.add_argument("-nw", "--num_workers", type=int, default=-1, help="Number of workers for data loading (default: -1, which sets it to 0 on macOS and 8 on Linux)")
    return vars(parser.parse_args())



def update_config_with_train_config(cfg: DictConfig, cfg_train: DictConfig) -> DictConfig:
    """
    Update the configuration with the training configuration to ensure consistency.
    Args:
        cfg (DictConfig): The original configuration.
        cfg_train (DictConfig): The training configuration.
    Returns:
        DictConfig: Updated configuration.
    """
    # Disable struct mode to allow adding new fields
    OmegaConf.set_struct(cfg, False)

    # Copy over specific globals and of run
    cfg.globals.cutoff = cfg_train.globals.cutoff
    cfg.globals.energy_key = cfg_train.globals.energy_key
    cfg.globals.forces_key = cfg_train.globals.forces_key
    cfg.run.mean_std_path = cfg_train.run.mean_std_path

    # Copy over data fields
    cfg.data = cfg_train.data
    # Create model field if it doesn't exist
    if 'model' not in cfg:
        cfg.model = DictConfig({})
    # Copy over model fields
    cfg.model.postprocessors = cfg_train.model.postprocessors

    # Re-enable struct mode to enforce the structure
    OmegaConf.set_struct(cfg, True)
    return cfg

def update_config(cfg: DictConfig, ase_units: dict, run_path: str, md_steps: int, time_step: float, num_workers: int) -> DictConfig:
    """ 
    Update the configuration with command-line arguments.
    Args:
        cfg (DictConfig): The original configuration.
        ase_units (dict): Dictionary containing ASE units.
        run_path (str): Path to save the run.
        md_steps (int): Number of MD steps to run.
        time_step (float): Time step for the MD simulation in atomic units.
        num_workers (int): Number of workers for data loading.
    Returns:
        DictConfig: Updated configuration.
    """
    cfg.run.path = run_path
    if num_workers != -1:
        cfg.data.num_workers = num_workers
    else:
        cfg.data.num_workers = 0 if platform.system() == 'Darwin' else 8
    cfg.md.n_steps = md_steps
    cfg.md.time_step = time_step 

    # Set the ASE units in the configuration
    cfg.org_data.distance_unit = ase_units['distance']
    cfg.org_data.property_units.energy = ase_units['energy']
    cfg.org_data.property_units.forces = ase_units['forces']

    return cfg



def prepare_atoms(structure: DictConfig, velocities: torch.Tensor, velocity_units: str = "angstrom/fs") -> Atoms:
    """
    Prepare an ASE Atoms object from the structure and velocities.
    Args:
        structure (DictConfig): The structure containing atomic numbers and positions.
        velocities (torch.Tensor): Velocities in specified units.
        velocity_units (str): Units of the velocities, default is "angstrom/fs".
    Returns:
        Atoms: ASE Atoms object with positions and velocities.
    """
    atoms = Atoms(
        numbers=structure[spk.properties.Z],
        positions=structure[spk.properties.R],
    )

    if isinstance(velocities, torch.Tensor):
        velocities = velocities.detach().cpu().numpy()
    else:
        raise TypeError(f"Unsupported type for velocities: {type(velocities)}. Expected torch.Tensor.")

    velocities_ase = convert_velocities(velocities, velocity_units, "angstrom/ase_time")
    atoms.set_velocities(velocities_ase)

    return atoms

def make_update_bar(pbar: tqdm, interval: int = 1):
    def update_bar(_=None):
        pbar.update(interval)
    return update_bar

def move_xtb_files_to_xtb_dir(xtb_dir: str):
    """
    Move the XTB output files to the specified xtb directory. This is necessary
    because the XTB calculator creates files in the current working directory,
    which may not be the same as the directory where the script is run.
    Args:
        xtb_dir (str): Path to the directory where XTB files should be moved.
    """
    xtb_files = ["charges", "coord.engrad", "coord.xyz", "energy", "gradient", "wbo", 
                 "xtb.inp", "xtb.out", "xtbout.json", "xtbrestart", "xtbtopo.mol"]
    current_dir = os.getcwd()
    for file in xtb_files:
        src = os.path.join(current_dir, file)
        dst = os.path.join(xtb_dir, file)
        if os.path.exists(src):
            os.rename(src, dst)
            logger.info(f"Moved {src} to {dst}")
        else:
            logger.warning(f"File {src} does not exist, skipping move.")

def save_traj_to_xyz(traj_path: str, xyz_path: str):
    """
    Save the trajectory from a .traj file to an .xyz file.
    Args:
        traj_path (str): Path to the input .traj file.
        xyz_path (str): Path to save the output .xyz file.
    """
    traj = read(traj_path, index=':')
    write(xyz_path, traj)
    logger.info(f"Saved trajectory from {traj_path} to {xyz_path}")

def main(trajectory_dir: str, units: str, model_dir: str, md_steps: int, time_step: float, fold: int, seed: int, num_workers: int):
    ####################### 1) Compose the config ###########################
    cfg = load_config(f"neural_net/conf/{units}", "inference_config", "inference")

    # use training config to update the inference config
    train_cfg_path = os.path.join("neural_net/runs", model_dir, cfg.globals.train_config_subpath)
    cfg_train = load_config(train_cfg_path, cfg.globals.hparams_file_name, "train")
    cfg = update_config_with_train_config(cfg, cfg_train)

    # update config with arguments from command line
    home_dir = os.path.expanduser("~")
    runs_dir_path = os.path.join(home_dir, cfg.globals.runs_dir_subpath)
    model_dir_path = os.path.join(runs_dir_path, model_dir)

    ase_units = get_ase_units_from_str(units)
    
    cfg = update_config(cfg, ase_units, model_dir_path, md_steps, time_step, num_workers)
    logger.info(f"Loaded and updated config:\n{OmegaConf.to_yaml(cfg)}")

    ####################### 2) Prepare Data and Paths #########################
    data_prefix = set_data_prefix()
    split_file = get_split_path(data_prefix, trajectory_dir, fold)
    path_to_db = os.path.join(data_prefix, trajectory_dir, f"md_trajectory_{units}.db")
    simulation_name = f"md_sim_steps_{md_steps}_time_step_{time_step}_seed_{seed}"
    target_dir = os.path.join(cfg.run.path, simulation_name)
    os.makedirs(target_dir)
    
    xtb_target_dir = os.path.join(runs_dir_path, cfg.globals.xtb_dir_name, simulation_name)
    xtb_cache_dir = os.path.join(xtb_target_dir, "xtb")
    os.makedirs(xtb_target_dir, exist_ok=True)
    os.makedirs(xtb_cache_dir, exist_ok=True)

    xtb_datamodule = setup_datamodule(data_cfg=cfg.org_data, datapath=path_to_db, split_file=split_file)
    nn_datamodule = setup_datamodule(data_cfg=cfg.data, datapath=path_to_db, split_file=split_file)

    # save config to the target directory
    config_path = os.path.join(target_dir, "inference_config.yaml")
    with open(config_path, 'w') as f:
        OmegaConf.save(cfg, f)
    exit()

    ####################### 3) Prepare molecule ##############################
    sample_idx = -1
    nn_structure = nn_datamodule.test_dataset[sample_idx]
    xtb_structure = xtb_datamodule.test_dataset[sample_idx]
    velocities_au = xtb_structure["velocities"]

    atoms_nn = prepare_atoms(nn_structure, velocities_au)
    atoms_xtb = prepare_atoms(xtb_structure, velocities_au)

    # check if velocities are valid by computing the corresponding temperature
    logger.info(f"Note that ase computes the temperature without subtracting any degrees of freedom, so it is not the same as the temperature computed by XTB")
    logger.info(f"Initial temperature of the system: {atoms_xtb.get_temperature()} K")
    logger.info(f"Initial kinetic energy of the system: {atoms_xtb.get_kinetic_energy()} eV") 

    ####################### 4) Setup calculators ##############################
    atoms_xtb.calc = XTB(method=cfg.xtb.method)
    nn_calculator: spk.interfaces.SpkCalculator = instantiate(cfg.calculator)
    atoms_nn.calc = nn_calculator

    ####################### 5) Setup simulator ##############################
    # convert time step from atomic units to seconds and then to ASE time units
    logger.debug(f"Time step (in fs): {cfg.md.time_step}")
    time_step_ase = convert_time(cfg.md.time_step, "fs", "ase_time")
    logger.debug(f"Time step (in ASE time units): {time_step_ase:.2f}")    

    dyn_nn = ASEVelocityVerlet(
        atoms_nn, time_step_ase, trajectory=f'{target_dir}/nn_traj.traj', logfile=f'{target_dir}/nn_md.log',
    )

    ####################### 6) Run simulations ##############################
    logger.info(f"Starting simulation with {cfg.md.n_steps} steps.")
    logger.info(f"Beginning simulation with neural network calculator and saving to {target_dir}.")
    
    # Create a tqdm progress bar
    interval = 1
    pbar = tqdm(total=cfg.md.n_steps, desc="MD progress")
    dyn_nn.attach(make_update_bar(pbar, interval), interval=interval)

    nn_start = time.time()
    dyn_nn.run(cfg.md.n_steps)
    nn_end = time.time()
    
    # Only run the XTB simulation, if it has not been run before
    if not os.path.exists(f'{xtb_target_dir}/xtb_traj.traj'):
        dyn_xtb = ASEVelocityVerlet(
            atoms_xtb, time_step_ase, trajectory=f'{xtb_target_dir}/xtb_traj.traj', logfile=f'{xtb_target_dir}/xtb_md.log',
        )
        # Silence the XTB output to avoid cluttering the console
        logging.getLogger('cclib').setLevel(logging.WARNING)
        
        # Create a tqdm progress bar
        interval = 10
        pbar = tqdm(total=cfg.md.n_steps, desc="MD progress")
        dyn_xtb.attach(make_update_bar(pbar, interval), interval=interval)

        logger.info(f"Beginning simulation with XTB calculator.")
        xtb_start = time.time()
        dyn_xtb.run(cfg.md.n_steps)
        xtb_end = time.time()
        logger.info(f"XTB time: {xtb_end - xtb_start:.2f} s")

        # Move the files created by the XTB calculator to the xtb directory
        move_xtb_files_to_xtb_dir(xtb_cache_dir)
        save_traj_to_xyz(f'{xtb_target_dir}/xtb_traj.traj', f'{xtb_target_dir}/xtb_traj.xyz')
    else:
        logger.info(f"XTB trajectory already exists at {xtb_target_dir}/xtb_traj.traj. Skipping XTB simulation.")

    logger.info(f"NN time: {nn_end - nn_start:.2f} s")
    save_traj_to_xyz(f'{target_dir}/nn_traj.traj', f'{target_dir}/nn_traj.xyz')


if __name__ == "__main__":
    args = parse_args()
    main(**args)


# TIMINGS
# 10 steps with 0.5 fs time step on pc54
# NN time: 0.77 s
# XTB time: 4.54 s

# 100 steps with 0.5 fs time step on pc54
# NN time: 6.97 s
# XTB time: 42.48 s


# 500 steps with 0.5 fs time step on pc54
# NN time: 17.90 s
# XTB time: 432.25 s ?!?!?!


# 5000 steps with 1 fs time step on pc54
# NN time: 337.57 s = 5.63 min
# XTB time:  2193.96 s = 36.57 min

# 10000 steps with 0.5 fs time step on pc54
# NN time: Not measured
# XTB time: 4143.98 s

# 10000 steps with 0.5 fs time step on pc54
# NN time: 322.48 s
# XTB time: 10036.13 s ?!?!
