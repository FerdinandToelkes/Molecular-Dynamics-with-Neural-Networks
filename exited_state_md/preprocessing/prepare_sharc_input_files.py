import os
import argparse
import numpy as np
import pandas as pd

import ase.data as ase_data


from ground_state_md.utils import set_data_prefix
from ground_state_md.setup_logger import setup_logger
from ground_state_md.preprocessing.prepare_xtb_data import get_atomic_numbers_from_xyz

from exited_state_md.preprocessing.utils import prepare_last_exited_cycles
from exited_state_md.preprocessing.prepare_tddft_data import get_property_paths


logger = setup_logger("info")


# Example command to run the script from within code directory:
"""
python -m exited_state_md.preprocessing.prepare_sharc_input_files --num_atoms 48 
"""

# Note: We are using SHARC 3.0 so the format are taken from the SHARC 3.0 tutorial, but some information is only available
# in the SHARC 4.0 tutorial, so we are using the SHARC 4.0 tutorial for some information.

def parse_args() -> dict:
    """ 
    Parse command-line arguments. 
    Returns:
        dict: Dictionary containing command-line arguments.
    """
    parser = argparse.ArgumentParser(description="Prepare TDDFT data for usage in SchNetPack")
    parser.add_argument("--target_dir", type=str, default="PREPARE_12", help="Directory containing the trajectory data generated by Turbomole (default: PREPARE_12)")
    parser.add_argument("--computed_cycles", type=int, default=1461, help="Number of cycles for which the gradients were computed (default: 1461)")
    parser.add_argument('--num_atoms', type=int, required=True, help='Number of atoms in the simulation. Can be found in the "control" file under "natoms".')
    return vars(parser.parse_args())


def get_initial_s0_energy_from_csv(path: str) -> float:
    """
    Extract the initial (potential) energy for the S0 state from a .csv file and return it as float.
    Args:
        path (str): Path to the .csv file.
    Returns:
        float: Initial (potential) energy for the S0 state.
    """
    df = pd.read_csv(path, comment='#')
    s0_energy = df['S0'].values[0]
    return s0_energy

def get_first_frame_from_txt(path: str, num_atoms: int, usecols: tuple[int] = (1, 2, 3)) -> np.ndarray:
    """
    Load the first frame from a .txt file and return it as a numpy array.
    Args:
        path (str): Path to the .txt file containing trajectory data.
        num_atoms (int): Number of atoms in the system.
        usecols (tuple[int]): Columns to use from the .txt file. Default is (1, 2, 3) which skips the element symbols.
    Returns:
        np.ndarray: First frame of the trajectory as a numpy array.
    """
    traj = np.loadtxt(path, usecols=usecols, comments=["#", "t="]) 
    traj = traj.reshape(-1, num_atoms, 3)  # Shape: (Nframes, Natoms, 3)
    first_frame = traj[0]  # Take the first frame as the initial geometry
    return first_frame

def read_in_properties(property_paths, num_atoms) -> dict:
    """
    Read in all properties from the prepared .csv and .txt files.
    Args:
        property_paths (dict): Dictionary containing paths to the necessary property files.
        num_atoms (int): Number of atoms in the simulation.
    Returns:
        dict: Dictionary containing all properties.
    """
    logger.debug("Extracting data from prepared .csv and .txt files")
    initial_s0_energy = get_initial_s0_energy_from_csv(property_paths['energy'])
    initial_geom = get_first_frame_from_txt(property_paths['traj'], num_atoms, usecols=(1, 2, 3))
    initial_velocities = get_first_frame_from_txt(property_paths['velocities'], num_atoms, usecols=(1, 2, 3)) 
    atomic_numbers = get_atomic_numbers_from_xyz(property_paths['traj'], num_atoms, extra_lines=3)

    logger.debug(f"Initial S0 energy: {initial_s0_energy}")
    logger.debug(f"Atomic numbers: {atomic_numbers}")
    logger.debug(f"Initial geometry shape: {initial_geom.shape}")
    logger.debug(f"Initial velocities shape: {initial_velocities.shape}")

    return {
        'initial_geometry': initial_geom,
        'initial_s0_energy': initial_s0_energy,
        'initial_velocities': initial_velocities,
        'atomic_numbers': atomic_numbers
    }

def write_initial_geometry_to_file(path_to_traj_dir: str, initial_geometry: np.ndarray, num_atoms: int, 
                                   atomic_symbols: list, atomic_numbers: list, atomic_masses: list):
    """
    Write the initial geometry to a file in the specified format for SHARC.
    Format taken from https://sharc-md.org/wp-content/uploads/2023/04/SHARC_Tutorial.pdf section 5.2
    Args:
        path_to_traj_dir (str): Path to the trajectory directory.
        initial_geometry (np.ndarray): Array containing initial geometry in atomic units.
        num_atoms (int): Number of atoms in the simulation.
        atomic_symbols (list): List of atomic symbols.
        atomic_numbers (list): List of atomic numbers.
        atomic_masses (list): List of atomic masses.
    """
    logger.debug("Writing initial geometry to file")
    initial_geometry_path = os.path.join(path_to_traj_dir, "geom")
    with open(initial_geometry_path, 'w') as f:
        f.write(f"{num_atoms}\n")
        f.write("# Initial geometry in Bohr\n")
        for symbol, nr, m, coords in zip(atomic_symbols, atomic_numbers, atomic_masses, initial_geometry):
            f.write(f"{symbol} {nr} {' '.join(map(str, coords))} {m}\n")

def write_initial_velocities_to_file(path_to_traj_dir: str, initial_velocities: np.ndarray, num_atoms: int):
    """
    Write the initial velocities to a file in the specified format for SHARC.
    Format taken from https://sharc-md.org/?page_id=1454#tth_sEc4.3 section 4.3 
    Args:
        path_to_traj_dir (str): Path to the trajectory directory.
        initial_velocities (np.ndarray): Array containing initial velocities in atomic units.
        num_atoms (int): Number of atoms in the simulation.
    """
    logger.debug("Writing initial velocities to file")
    initial_velocities_path = os.path.join(path_to_traj_dir, "veloc")
    with open(initial_velocities_path, 'w') as f:
        f.write(f"{num_atoms}\n")
        f.write("# Initial velocities in Bohr/aut\n")
        for vel in initial_velocities:
            f.write(f"{' '.join(map(str, vel))}\n")

def copy_info_template_to_traj_dir(path_to_traj_dir: str, initial_s0_energy: float):
    """
    Copy the info template to the trajectory directory and replace the ezero line with the initial S0 energy.
    Args:
        path_to_traj_dir (str): Path to the trajectory directory.
        initial_s0_energy (float): Initial S0 energy.
    Raises:
        FileNotFoundError: If the input template file is not found.
    """
    logger.debug("Copying info template to trajectory directory")
    path_to_input_template = "./exited_state_md/training_and_inference/conf/input"
    if not os.path.exists(path_to_input_template):
        raise FileNotFoundError(f"Input template file not found at {path_to_input_template}")
    
    # copy the info template to the trajectory directory
    info_path = os.path.join(path_to_traj_dir, "input")
    with open(path_to_input_template, 'r') as template_file:
        template_content = template_file.read()
    
    # replace the ezero line (e.g. ezero none) with ezero <initial_s0_energy>
    for line in template_content.splitlines():
        if line.startswith("ezero"):
            template_content = template_content.replace(line, f"ezero {initial_s0_energy}")
            break
    
    with open(info_path, 'w') as info_file:
        info_file.write(template_content)

def main(target_dir: str, computed_cycles: int, num_atoms: int):
    """
    Main function to prepare XTB data in units of Angstrom and kcal/mol for usage in SchNetPack.
    Args:
        target_dir (str): Directory containing the GEO folders containing exited state trajectories generated by Turbomole.
        computed_cycles (int): Number of cycles for which the gradients were computed.
        num_atoms (int): Number of atoms in the simulation. Can be found in the "control" file under "natoms".
    """
    # setup paths to the necessary files
    data_path = os.path.join(set_data_prefix(), target_dir)
    path_to_input_template = "./exited_state_md/training_and_inference/conf/input"


    # get all valid trajectories and the number of their last exited cycles
    geo_dirs_with_last_exited_cycles = prepare_last_exited_cycles(data_path, computed_cycles)


    for geo_dir in geo_dirs_with_last_exited_cycles.keys():
        logger.info(f"Processing GEO folder: {geo_dir}")
        # setup paths to the necessary files
        data_prefix = os.path.join(data_path, geo_dir, "test")
        property_paths = get_property_paths(data_prefix)
        path_to_traj_dir = os.path.join(data_prefix, "sharc_trajectory")
        os.makedirs(path_to_traj_dir, exist_ok=True)
        # read in all properties from the prepared .csv and .txt files
        properties = read_in_properties(property_paths, num_atoms)
        atomic_numbers = properties['atomic_numbers']
        atomic_symbols = [ase_data.chemical_symbols[atomic_number] for atomic_number in atomic_numbers]
        atomic_masses = [ase_data.atomic_masses[atomic_number] for atomic_number in atomic_numbers]
        logger.debug(f"Atomic symbols: {atomic_symbols}")
        logger.debug(f"Atomic masses: {atomic_masses}")

        # write initial geometry in Bohr (format of columbus)
        write_initial_geometry_to_file(path_to_traj_dir, properties["initial_geometry"], num_atoms, atomic_symbols, atomic_numbers, atomic_masses)

        # write initial velocities in Bohr/aut (format of columbus)
        write_initial_velocities_to_file(path_to_traj_dir, properties['initial_velocities'], num_atoms)

        # copy the info template to the trajectory directory and replace the ezero line with the initial S0 energy
        copy_info_template_to_traj_dir(path_to_traj_dir, properties['initial_s0_energy'])

        
    

if __name__=="__main__":
    args = parse_args()
    main(**args)