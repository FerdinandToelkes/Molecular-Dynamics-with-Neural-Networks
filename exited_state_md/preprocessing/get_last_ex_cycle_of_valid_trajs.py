import os
import argparse

from ground_state_md.utils import set_data_prefix
from ground_state_md.setup_logger import setup_logger

# Example command to run the script from within code directory:
"""
python3 -m exited_md.preprocessing.get_last_ex_cycle_of_valid_trajs --target_dir PREPARE_12
"""

logger = setup_logger(logging_level_str="info")

def parse_args() -> dict:
    """ Parse command-line arguments. 

    Returns:
        dict: Dictionary containing command-line arguments.
    """
    parser = argparse.ArgumentParser(description="Extract hop cycle (last exited cycle) of valid trajectories.")
    parser.add_argument("--target_dir", type=str, default="PREPARE_12", help="Directory containing the trajectory data generated by Turbomole (default: PREPARE_12)")
    parser.add_argument("--expected_cycles", type=int, default=3001, help="Expected number of cycles in the RUN.dat file of a valid trajectory (default: 3001). Note that the last one is an extra cycle, due to the $current $end block in the mdlog files.")
    return vars(parser.parse_args())

def get_geo_dirs(data_path: str) -> list:
    """
    Get all GEO_ directories in the given path.
    Args:
        data_path (str): Path to the directory containing GEO_ directories.
    Returns:
        list: Sorted list of GEO_ directories.
    """
    geo_dirs = [d for d in os.listdir(data_path) if d.startswith("GEO_") and os.path.isdir(os.path.join(data_path, d))]
    if not geo_dirs:
        raise FileNotFoundError(f"No GEO_ directories found in {data_path}. Please check the path.")
    geo_dirs.sort()  # Sort directories to maintain order
    logger.debug(f"Found {len(geo_dirs)} GEO_ directories: {geo_dirs}")
    return geo_dirs

def get_number_of_cycles(path: str) -> int:
    """
    Get the number of cycles from the RUN.dat file.
    Args:
        path (str): Path to the RUN.dat file.
    Returns:
        int: The number of cycles.
    """
    with open(path, 'r') as f:
        # Count the number of lines in the file that are not empty
        number_of_cycles = sum(1 for line in f if line.strip())
        logger.debug(f"Number of cycles: {number_of_cycles}")
        return number_of_cycles

def get_last_exited_cycle(path: str, number_of_cycles: int) -> int:
    """
    Get the last exited cycle from the RUN.dat file. The working assumption is that the first configuration is in the exited state (1) and that there is only one hop.
    If the first configuration is not in the exited state, an error is raised.
    Args:
        path (str): Path to the RUN.dat file.
        number_of_cycles (int): The number of cycles.
    Raises:
        ValueError: If the first configuration is not in the exited state or if there are multiple hops.
    Returns:
        int: The last exited cycle.
    """
    exited_state = 1
    previous_state = exited_state 
    has_hopped = False
    last_exited_cycle = number_of_cycles
    with open(path, 'r') as f:
        for i, line in enumerate(f):
            active_state = int(line.strip())
            if i == 0 and active_state != exited_state:
                raise ValueError("The first configuration should be in the exited state.")
            
            if active_state != previous_state:
                if has_hopped:
                    raise ValueError("Active state should remain in ground state after a hop.") # Pragati's assumption
                has_hopped = True
                last_exited_cycle = i # again, assuming only one hop 
                logger.debug(f"Configuration changed from {previous_state} to {active_state} at line {i}.")
            previous_state = active_state
    logger.debug(f"Last exited cycle: {last_exited_cycle}")
    return last_exited_cycle

def save_last_exited_cycles_to_file(last_exited_cycles: dict, data_path: str):
    """
    Save the last exited cycles to a text file.
    Args:
        last_exited_cycles (dict): Dictionary containing the last exited cycles for each trajectory.
        data_path (str): Path to the directory where the text file will be saved.
    """
    # save the last exited cycles to a text file
    output_path = os.path.join(data_path, "last_exited_cycle_of_valid_trajectories.txt")
    with open(output_path, 'w') as f:
        for geo_dir, last_cycle in last_exited_cycles.items():
            f.write(f"{geo_dir}: {last_cycle}\n")
    logger.info(f"Last exited cycles saved to {output_path}")

def main(target_dir: str, expected_cycles: int):
    """
    Main function to extract the last exited cycle of valid trajectories.
    Args:
        target_dir (str): Directory where the log files are located.
        expected_cycles (int): Expected number of cycles in the RUN.dat file.
    """
    # setup
    data_path = os.path.join(set_data_prefix(), target_dir)
    logger.debug(f"data_path: {data_path}")
    last_exited_cycles = {}

    # get all GEO_ directories
    geo_dirs = get_geo_dirs(data_path)

    for geo_dir in geo_dirs:
        # read the RUN.dat file to check for hops
        path = os.path.join(data_path, geo_dir, "test", "RUN.dat")
        if not os.path.exists(path):
            logger.warning(f"RUN.dat file does not exist in {data_path}. Skipping the {geo_dir} directory.")
            continue

        number_of_cycles = get_number_of_cycles(path)
        if number_of_cycles != expected_cycles:
            logger.warning(f"Expected {expected_cycles} cycles, but found {number_of_cycles} cycles in {geo_dir}. Skipping this directory.")
            continue
        
        last_exited_cycle = get_last_exited_cycle(path, number_of_cycles)
        last_exited_cycles[geo_dir] = last_exited_cycle
    
    # save the last exited cycles to a text file
    logger.info(f"Found {len(last_exited_cycles)} valid trajectories with last exited cycles: {last_exited_cycles}")
    save_last_exited_cycles_to_file(last_exited_cycles, data_path)
    
if __name__ == "__main__":
    args = parse_args()
    main(**args)
    
        